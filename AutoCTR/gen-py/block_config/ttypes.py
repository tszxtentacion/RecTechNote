#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except ImportError:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ExtendedBlockType', 'FeatSelectionConfig', 'DenseBlockType', 'EmbedBlockType', 'BlockType', 'MLPBlockConfig', 'CrossNetBlockConfig', 'FMBlockConfig', 'DotProcessorBlockConfig', 'CatBlockConfig', 'CINBlockConfig', 'AttentionBlockConfig', 'BlockConfig']

class ExtendedBlockType:
  MLP_DENSE = 1
  MLP_EMB = 2
  CROSSNET = 3
  FM_DENSE = 4
  FM_EMB = 5
  DOTPROCESSOR_DENSE = 6
  DOTPROCESSOR_EMB = 7
  CAT_DENSE = 8
  CAT_EMB = 9
  CIN = 10
  ATTENTION = 11

  _VALUES_TO_NAMES = {
    1: "MLP_DENSE",
    2: "MLP_EMB",
    3: "CROSSNET",
    4: "FM_DENSE",
    5: "FM_EMB",
    6: "DOTPROCESSOR_DENSE",
    7: "DOTPROCESSOR_EMB",
    8: "CAT_DENSE",
    9: "CAT_EMB",
    10: "CIN",
    11: "ATTENTION",
  }

  _NAMES_TO_VALUES = {
    "MLP_DENSE": 1,
    "MLP_EMB": 2,
    "CROSSNET": 3,
    "FM_DENSE": 4,
    "FM_EMB": 5,
    "DOTPROCESSOR_DENSE": 6,
    "DOTPROCESSOR_EMB": 7,
    "CAT_DENSE": 8,
    "CAT_EMB": 9,
    "CIN": 10,
    "ATTENTION": 11,
  }

class FeatSelectionConfig:
  """
  Attributes:
   - block_id
   - dense
   - sparse
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.dense = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = iprot.readI32()
              self.dense.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI32()
              self.dense.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.sparse = []
          (_etype10, _size7) = iprot.readListBegin()
          if _size7 >= 0:
            for _i11 in six.moves.range(_size7):
              _elem12 = iprot.readI32()
              self.sparse.append(_elem12)
          else: 
            while iprot.peekList():
              _elem13 = iprot.readI32()
              self.sparse.append(_elem13)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FeatSelectionConfig')
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 1)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.dense != None:
      oprot.writeFieldBegin('dense', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.dense))
      for iter14 in self.dense:
        oprot.writeI32(iter14)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sparse != None:
      oprot.writeFieldBegin('sparse', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.sparse))
      for iter15 in self.sparse:
        oprot.writeI32(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.dense is not None:
      value = pprint.pformat(self.dense, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dense=%s' % (value))
    if self.sparse is not None:
      value = pprint.pformat(self.sparse, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sparse=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DenseBlockType:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DenseBlockType')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EmbedBlockType:
  """
  Attributes:
   - comm_embed_dim
   - dense_as_sparse
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.comm_embed_dim = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.dense_as_sparse = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EmbedBlockType')
    if self.comm_embed_dim != None:
      oprot.writeFieldBegin('comm_embed_dim', TType.I32, 1)
      oprot.writeI32(self.comm_embed_dim)
      oprot.writeFieldEnd()
    if self.dense_as_sparse != None:
      oprot.writeFieldBegin('dense_as_sparse', TType.BOOL, 2)
      oprot.writeBool(self.dense_as_sparse)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.comm_embed_dim is not None:
      value = pprint.pformat(self.comm_embed_dim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comm_embed_dim=%s' % (value))
    if self.dense_as_sparse is not None:
      value = pprint.pformat(self.dense_as_sparse, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dense_as_sparse=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BlockType(object):
  """
  Attributes:
   - dense
   - emb
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  DENSE = 1
  EMB = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_dense(self):
    assert self.field == 1
    return self.value

  def get_emb(self):
    assert self.field == 2
    return self.value

  def set_dense(self, value):
    self.field = 1
    self.value = value

  def set_emb(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dense', value)
    if self.field == 2:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('emb', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          dense = DenseBlockType()
          dense.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dense(dense)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          emb = EmbedBlockType()
          emb.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_emb(emb)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('BlockType')
    if self.field == 1:
      oprot.writeFieldBegin('dense', TType.STRUCT, 1)
      dense = self.value
      dense.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('emb', TType.STRUCT, 2)
      emb = self.value
      emb.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MLPBlockConfig:
  """
  Attributes:
   - name
   - block_id
   - input_feat_config
   - type
   - arc
   - ly_act
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_feat_config = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _elem21 = FeatSelectionConfig()
              _elem21.read(iprot)
              self.input_feat_config.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = FeatSelectionConfig()
              _elem22.read(iprot)
              self.input_feat_config.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.type = BlockType()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.arc = []
          (_etype26, _size23) = iprot.readListBegin()
          if _size23 >= 0:
            for _i27 in six.moves.range(_size23):
              _elem28 = iprot.readI32()
              self.arc.append(_elem28)
          else: 
            while iprot.peekList():
              _elem29 = iprot.readI32()
              self.arc.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.ly_act = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MLPBlockConfig')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 2)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.input_feat_config != None:
      oprot.writeFieldBegin('input_feat_config', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.input_feat_config))
      for iter30 in self.input_feat_config:
        iter30.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRUCT, 4)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    if self.arc != None:
      oprot.writeFieldBegin('arc', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.arc))
      for iter31 in self.arc:
        oprot.writeI32(iter31)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ly_act != None:
      oprot.writeFieldBegin('ly_act', TType.BOOL, 6)
      oprot.writeBool(self.ly_act)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.input_feat_config is not None:
      value = pprint.pformat(self.input_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    input_feat_config=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.arc is not None:
      value = pprint.pformat(self.arc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    arc=%s' % (value))
    if self.ly_act is not None:
      value = pprint.pformat(self.ly_act, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ly_act=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CrossNetBlockConfig:
  """
  Attributes:
   - name
   - block_id
   - input_feat_config
   - num_of_layers
   - cross_feat_config
   - batchnorm
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_feat_config = []
          (_etype35, _size32) = iprot.readListBegin()
          if _size32 >= 0:
            for _i36 in six.moves.range(_size32):
              _elem37 = FeatSelectionConfig()
              _elem37.read(iprot)
              self.input_feat_config.append(_elem37)
          else: 
            while iprot.peekList():
              _elem38 = FeatSelectionConfig()
              _elem38.read(iprot)
              self.input_feat_config.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.num_of_layers = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.cross_feat_config = []
          (_etype42, _size39) = iprot.readListBegin()
          if _size39 >= 0:
            for _i43 in six.moves.range(_size39):
              _elem44 = FeatSelectionConfig()
              _elem44.read(iprot)
              self.cross_feat_config.append(_elem44)
          else: 
            while iprot.peekList():
              _elem45 = FeatSelectionConfig()
              _elem45.read(iprot)
              self.cross_feat_config.append(_elem45)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.batchnorm = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CrossNetBlockConfig')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 2)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.input_feat_config != None:
      oprot.writeFieldBegin('input_feat_config', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.input_feat_config))
      for iter46 in self.input_feat_config:
        iter46.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.num_of_layers != None:
      oprot.writeFieldBegin('num_of_layers', TType.I32, 4)
      oprot.writeI32(self.num_of_layers)
      oprot.writeFieldEnd()
    if self.cross_feat_config != None:
      oprot.writeFieldBegin('cross_feat_config', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.cross_feat_config))
      for iter47 in self.cross_feat_config:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.batchnorm != None:
      oprot.writeFieldBegin('batchnorm', TType.BOOL, 6)
      oprot.writeBool(self.batchnorm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.input_feat_config is not None:
      value = pprint.pformat(self.input_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    input_feat_config=%s' % (value))
    if self.num_of_layers is not None:
      value = pprint.pformat(self.num_of_layers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_of_layers=%s' % (value))
    if self.cross_feat_config is not None:
      value = pprint.pformat(self.cross_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cross_feat_config=%s' % (value))
    if self.batchnorm is not None:
      value = pprint.pformat(self.batchnorm, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    batchnorm=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class FMBlockConfig:
  """
  Attributes:
   - name
   - block_id
   - input_feat_config
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_feat_config = []
          (_etype51, _size48) = iprot.readListBegin()
          if _size48 >= 0:
            for _i52 in six.moves.range(_size48):
              _elem53 = FeatSelectionConfig()
              _elem53.read(iprot)
              self.input_feat_config.append(_elem53)
          else: 
            while iprot.peekList():
              _elem54 = FeatSelectionConfig()
              _elem54.read(iprot)
              self.input_feat_config.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.type = BlockType()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FMBlockConfig')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 2)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.input_feat_config != None:
      oprot.writeFieldBegin('input_feat_config', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.input_feat_config))
      for iter55 in self.input_feat_config:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRUCT, 4)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.input_feat_config is not None:
      value = pprint.pformat(self.input_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    input_feat_config=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DotProcessorBlockConfig:
  """
  Attributes:
   - name
   - block_id
   - input_feat_config
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_feat_config = []
          (_etype59, _size56) = iprot.readListBegin()
          if _size56 >= 0:
            for _i60 in six.moves.range(_size56):
              _elem61 = FeatSelectionConfig()
              _elem61.read(iprot)
              self.input_feat_config.append(_elem61)
          else: 
            while iprot.peekList():
              _elem62 = FeatSelectionConfig()
              _elem62.read(iprot)
              self.input_feat_config.append(_elem62)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.type = BlockType()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DotProcessorBlockConfig')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 2)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.input_feat_config != None:
      oprot.writeFieldBegin('input_feat_config', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.input_feat_config))
      for iter63 in self.input_feat_config:
        iter63.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRUCT, 4)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.input_feat_config is not None:
      value = pprint.pformat(self.input_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    input_feat_config=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CatBlockConfig:
  """
  Attributes:
   - name
   - block_id
   - input_feat_config
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_feat_config = []
          (_etype67, _size64) = iprot.readListBegin()
          if _size64 >= 0:
            for _i68 in six.moves.range(_size64):
              _elem69 = FeatSelectionConfig()
              _elem69.read(iprot)
              self.input_feat_config.append(_elem69)
          else: 
            while iprot.peekList():
              _elem70 = FeatSelectionConfig()
              _elem70.read(iprot)
              self.input_feat_config.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.type = BlockType()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CatBlockConfig')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 2)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.input_feat_config != None:
      oprot.writeFieldBegin('input_feat_config', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.input_feat_config))
      for iter71 in self.input_feat_config:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRUCT, 4)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.input_feat_config is not None:
      value = pprint.pformat(self.input_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    input_feat_config=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CINBlockConfig:
  """
  Attributes:
   - name
   - block_id
   - input_feat_config
   - emb_config
   - arc
   - split_half
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_feat_config = []
          (_etype75, _size72) = iprot.readListBegin()
          if _size72 >= 0:
            for _i76 in six.moves.range(_size72):
              _elem77 = FeatSelectionConfig()
              _elem77.read(iprot)
              self.input_feat_config.append(_elem77)
          else: 
            while iprot.peekList():
              _elem78 = FeatSelectionConfig()
              _elem78.read(iprot)
              self.input_feat_config.append(_elem78)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.emb_config = EmbedBlockType()
          self.emb_config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.arc = []
          (_etype82, _size79) = iprot.readListBegin()
          if _size79 >= 0:
            for _i83 in six.moves.range(_size79):
              _elem84 = iprot.readI32()
              self.arc.append(_elem84)
          else: 
            while iprot.peekList():
              _elem85 = iprot.readI32()
              self.arc.append(_elem85)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.split_half = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CINBlockConfig')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 2)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.input_feat_config != None:
      oprot.writeFieldBegin('input_feat_config', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.input_feat_config))
      for iter86 in self.input_feat_config:
        iter86.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.emb_config != None:
      oprot.writeFieldBegin('emb_config', TType.STRUCT, 4)
      self.emb_config.write(oprot)
      oprot.writeFieldEnd()
    if self.arc != None:
      oprot.writeFieldBegin('arc', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.arc))
      for iter87 in self.arc:
        oprot.writeI32(iter87)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.split_half != None:
      oprot.writeFieldBegin('split_half', TType.BOOL, 6)
      oprot.writeBool(self.split_half)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.input_feat_config is not None:
      value = pprint.pformat(self.input_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    input_feat_config=%s' % (value))
    if self.emb_config is not None:
      value = pprint.pformat(self.emb_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    emb_config=%s' % (value))
    if self.arc is not None:
      value = pprint.pformat(self.arc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    arc=%s' % (value))
    if self.split_half is not None:
      value = pprint.pformat(self.split_half, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    split_half=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AttentionBlockConfig:
  """
  Attributes:
   - name
   - block_id
   - input_feat_config
   - emb_config
   - att_embed_dim
   - num_of_heads
   - num_of_layers
   - dropout_prob
   - use_res
   - batchnorm
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_feat_config = []
          (_etype91, _size88) = iprot.readListBegin()
          if _size88 >= 0:
            for _i92 in six.moves.range(_size88):
              _elem93 = FeatSelectionConfig()
              _elem93.read(iprot)
              self.input_feat_config.append(_elem93)
          else: 
            while iprot.peekList():
              _elem94 = FeatSelectionConfig()
              _elem94.read(iprot)
              self.input_feat_config.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.emb_config = EmbedBlockType()
          self.emb_config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.att_embed_dim = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.num_of_heads = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.num_of_layers = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.FLOAT:
          self.dropout_prob = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.use_res = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.batchnorm = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AttentionBlockConfig')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.block_id != None:
      oprot.writeFieldBegin('block_id', TType.I32, 2)
      oprot.writeI32(self.block_id)
      oprot.writeFieldEnd()
    if self.input_feat_config != None:
      oprot.writeFieldBegin('input_feat_config', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.input_feat_config))
      for iter95 in self.input_feat_config:
        iter95.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.emb_config != None:
      oprot.writeFieldBegin('emb_config', TType.STRUCT, 4)
      self.emb_config.write(oprot)
      oprot.writeFieldEnd()
    if self.att_embed_dim != None:
      oprot.writeFieldBegin('att_embed_dim', TType.I32, 5)
      oprot.writeI32(self.att_embed_dim)
      oprot.writeFieldEnd()
    if self.num_of_heads != None:
      oprot.writeFieldBegin('num_of_heads', TType.I32, 6)
      oprot.writeI32(self.num_of_heads)
      oprot.writeFieldEnd()
    if self.num_of_layers != None:
      oprot.writeFieldBegin('num_of_layers', TType.I32, 7)
      oprot.writeI32(self.num_of_layers)
      oprot.writeFieldEnd()
    if self.dropout_prob != None:
      oprot.writeFieldBegin('dropout_prob', TType.FLOAT, 8)
      oprot.writeFloat(self.dropout_prob)
      oprot.writeFieldEnd()
    if self.use_res != None:
      oprot.writeFieldBegin('use_res', TType.BOOL, 9)
      oprot.writeBool(self.use_res)
      oprot.writeFieldEnd()
    if self.batchnorm != None:
      oprot.writeFieldBegin('batchnorm', TType.BOOL, 10)
      oprot.writeBool(self.batchnorm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.block_id is not None:
      value = pprint.pformat(self.block_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_id=%s' % (value))
    if self.input_feat_config is not None:
      value = pprint.pformat(self.input_feat_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    input_feat_config=%s' % (value))
    if self.emb_config is not None:
      value = pprint.pformat(self.emb_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    emb_config=%s' % (value))
    if self.att_embed_dim is not None:
      value = pprint.pformat(self.att_embed_dim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    att_embed_dim=%s' % (value))
    if self.num_of_heads is not None:
      value = pprint.pformat(self.num_of_heads, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_of_heads=%s' % (value))
    if self.num_of_layers is not None:
      value = pprint.pformat(self.num_of_layers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_of_layers=%s' % (value))
    if self.dropout_prob is not None:
      value = pprint.pformat(self.dropout_prob, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dropout_prob=%s' % (value))
    if self.use_res is not None:
      value = pprint.pformat(self.use_res, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    use_res=%s' % (value))
    if self.batchnorm is not None:
      value = pprint.pformat(self.batchnorm, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    batchnorm=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BlockConfig(object):
  """
  Attributes:
   - mlp_block
   - crossnet_block
   - fm_block
   - dotprocessor_block
   - cat_block
   - cin_block
   - attention_block
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  MLP_BLOCK = 1
  CROSSNET_BLOCK = 2
  FM_BLOCK = 3
  DOTPROCESSOR_BLOCK = 4
  CAT_BLOCK = 5
  CIN_BLOCK = 6
  ATTENTION_BLOCK = 7
  
  @staticmethod
  def isUnion():
    return True

  def get_mlp_block(self):
    assert self.field == 1
    return self.value

  def get_crossnet_block(self):
    assert self.field == 2
    return self.value

  def get_fm_block(self):
    assert self.field == 3
    return self.value

  def get_dotprocessor_block(self):
    assert self.field == 4
    return self.value

  def get_cat_block(self):
    assert self.field == 5
    return self.value

  def get_cin_block(self):
    assert self.field == 6
    return self.value

  def get_attention_block(self):
    assert self.field == 7
    return self.value

  def set_mlp_block(self, value):
    self.field = 1
    self.value = value

  def set_crossnet_block(self, value):
    self.field = 2
    self.value = value

  def set_fm_block(self, value):
    self.field = 3
    self.value = value

  def set_dotprocessor_block(self, value):
    self.field = 4
    self.value = value

  def set_cat_block(self, value):
    self.field = 5
    self.value = value

  def set_cin_block(self, value):
    self.field = 6
    self.value = value

  def set_attention_block(self, value):
    self.field = 7
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mlp_block', value)
    if self.field == 2:
      padding = ' ' * 15
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('crossnet_block', value)
    if self.field == 3:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('fm_block', value)
    if self.field == 4:
      padding = ' ' * 19
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dotprocessor_block', value)
    if self.field == 5:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('cat_block', value)
    if self.field == 6:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('cin_block', value)
    if self.field == 7:
      padding = ' ' * 16
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('attention_block', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          mlp_block = MLPBlockConfig()
          mlp_block.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_mlp_block(mlp_block)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          crossnet_block = CrossNetBlockConfig()
          crossnet_block.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_crossnet_block(crossnet_block)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          fm_block = FMBlockConfig()
          fm_block.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_fm_block(fm_block)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          dotprocessor_block = DotProcessorBlockConfig()
          dotprocessor_block.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dotprocessor_block(dotprocessor_block)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          cat_block = CatBlockConfig()
          cat_block.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_cat_block(cat_block)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          cin_block = CINBlockConfig()
          cin_block.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_cin_block(cin_block)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          attention_block = AttentionBlockConfig()
          attention_block.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_attention_block(attention_block)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('BlockConfig')
    if self.field == 1:
      oprot.writeFieldBegin('mlp_block', TType.STRUCT, 1)
      mlp_block = self.value
      mlp_block.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('crossnet_block', TType.STRUCT, 2)
      crossnet_block = self.value
      crossnet_block.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('fm_block', TType.STRUCT, 3)
      fm_block = self.value
      fm_block.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('dotprocessor_block', TType.STRUCT, 4)
      dotprocessor_block = self.value
      dotprocessor_block.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('cat_block', TType.STRUCT, 5)
      cat_block = self.value
      cat_block.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('cin_block', TType.STRUCT, 6)
      cin_block = self.value
      cin_block.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('attention_block', TType.STRUCT, 7)
      attention_block = self.value
      attention_block.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(FeatSelectionConfig)
FeatSelectionConfig.thrift_spec = (
  None, # 0
  (1, TType.I32, 'block_id', None, None, 2, ), # 1
  (2, TType.LIST, 'dense', (TType.I32,None), None, 2, ), # 2
  (3, TType.LIST, 'sparse', (TType.I32,None), None, 2, ), # 3
)

FeatSelectionConfig.thrift_struct_annotations = {
}
FeatSelectionConfig.thrift_field_annotations = {
}

def FeatSelectionConfig__init__(self, block_id=None, dense=None, sparse=None,):
  self.block_id = block_id
  self.dense = dense
  self.sparse = sparse

FeatSelectionConfig.__init__ = FeatSelectionConfig__init__

def FeatSelectionConfig__setstate__(self, state):
  state.setdefault('block_id', None)
  state.setdefault('dense', None)
  state.setdefault('sparse', None)
  self.__dict__ = state

FeatSelectionConfig.__getstate__ = lambda self: self.__dict__.copy()
FeatSelectionConfig.__setstate__ = FeatSelectionConfig__setstate__

all_structs.append(DenseBlockType)
DenseBlockType.thrift_spec = (
)

DenseBlockType.thrift_struct_annotations = {
}
DenseBlockType.thrift_field_annotations = {
}

all_structs.append(EmbedBlockType)
EmbedBlockType.thrift_spec = (
  None, # 0
  (1, TType.I32, 'comm_embed_dim', None, None, 2, ), # 1
  (2, TType.BOOL, 'dense_as_sparse', None, False, 2, ), # 2
)

EmbedBlockType.thrift_struct_annotations = {
}
EmbedBlockType.thrift_field_annotations = {
}

def EmbedBlockType__init__(self, comm_embed_dim=None, dense_as_sparse=EmbedBlockType.thrift_spec[2][4],):
  self.comm_embed_dim = comm_embed_dim
  self.dense_as_sparse = dense_as_sparse

EmbedBlockType.__init__ = EmbedBlockType__init__

def EmbedBlockType__setstate__(self, state):
  state.setdefault('comm_embed_dim', None)
  state.setdefault('dense_as_sparse', False)
  self.__dict__ = state

EmbedBlockType.__getstate__ = lambda self: self.__dict__.copy()
EmbedBlockType.__setstate__ = EmbedBlockType__setstate__

all_structs.append(BlockType)
BlockType.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'dense', [DenseBlockType, DenseBlockType.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'emb', [EmbedBlockType, EmbedBlockType.thrift_spec, False], None, 2, ), # 2
)

BlockType.thrift_struct_annotations = {
}
BlockType.thrift_field_annotations = {
}

def BlockType__init__(self, dense=None, emb=None,):
  self.field = 0
  self.value = None
  if dense is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = dense
  if emb is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = emb

BlockType.__init__ = BlockType__init__

all_structs.append(MLPBlockConfig)
MLPBlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, "MLPBlock", 2, ), # 1
  (2, TType.I32, 'block_id', None, None, 2, ), # 2
  (3, TType.LIST, 'input_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'type', [BlockType, BlockType.thrift_spec, True], None, 2, ), # 4
  (5, TType.LIST, 'arc', (TType.I32,None), None, 2, ), # 5
  (6, TType.BOOL, 'ly_act', None, True, 2, ), # 6
)

MLPBlockConfig.thrift_struct_annotations = {
}
MLPBlockConfig.thrift_field_annotations = {
}

def MLPBlockConfig__init__(self, name=MLPBlockConfig.thrift_spec[1][4], block_id=None, input_feat_config=None, type=None, arc=None, ly_act=MLPBlockConfig.thrift_spec[6][4],):
  self.name = name
  self.block_id = block_id
  self.input_feat_config = input_feat_config
  self.type = type
  self.arc = arc
  self.ly_act = ly_act

MLPBlockConfig.__init__ = MLPBlockConfig__init__

def MLPBlockConfig__setstate__(self, state):
  state.setdefault('name', "MLPBlock")
  state.setdefault('block_id', None)
  state.setdefault('input_feat_config', None)
  state.setdefault('type', None)
  state.setdefault('arc', None)
  state.setdefault('ly_act', True)
  self.__dict__ = state

MLPBlockConfig.__getstate__ = lambda self: self.__dict__.copy()
MLPBlockConfig.__setstate__ = MLPBlockConfig__setstate__

all_structs.append(CrossNetBlockConfig)
CrossNetBlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, "CrossNetBlock", 2, ), # 1
  (2, TType.I32, 'block_id', None, None, 2, ), # 2
  (3, TType.LIST, 'input_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 3
  (4, TType.I32, 'num_of_layers', None, 2, 2, ), # 4
  (5, TType.LIST, 'cross_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 5
  (6, TType.BOOL, 'batchnorm', None, False, 2, ), # 6
)

CrossNetBlockConfig.thrift_struct_annotations = {
}
CrossNetBlockConfig.thrift_field_annotations = {
}

def CrossNetBlockConfig__init__(self, name=CrossNetBlockConfig.thrift_spec[1][4], block_id=None, input_feat_config=None, num_of_layers=CrossNetBlockConfig.thrift_spec[4][4], cross_feat_config=None, batchnorm=CrossNetBlockConfig.thrift_spec[6][4],):
  self.name = name
  self.block_id = block_id
  self.input_feat_config = input_feat_config
  self.num_of_layers = num_of_layers
  self.cross_feat_config = cross_feat_config
  self.batchnorm = batchnorm

CrossNetBlockConfig.__init__ = CrossNetBlockConfig__init__

def CrossNetBlockConfig__setstate__(self, state):
  state.setdefault('name', "CrossNetBlock")
  state.setdefault('block_id', None)
  state.setdefault('input_feat_config', None)
  state.setdefault('num_of_layers', 2)
  state.setdefault('cross_feat_config', None)
  state.setdefault('batchnorm', False)
  self.__dict__ = state

CrossNetBlockConfig.__getstate__ = lambda self: self.__dict__.copy()
CrossNetBlockConfig.__setstate__ = CrossNetBlockConfig__setstate__

all_structs.append(FMBlockConfig)
FMBlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, "FMBlock", 2, ), # 1
  (2, TType.I32, 'block_id', None, None, 2, ), # 2
  (3, TType.LIST, 'input_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'type', [BlockType, BlockType.thrift_spec, True], None, 2, ), # 4
)

FMBlockConfig.thrift_struct_annotations = {
}
FMBlockConfig.thrift_field_annotations = {
}

def FMBlockConfig__init__(self, name=FMBlockConfig.thrift_spec[1][4], block_id=None, input_feat_config=None, type=None,):
  self.name = name
  self.block_id = block_id
  self.input_feat_config = input_feat_config
  self.type = type

FMBlockConfig.__init__ = FMBlockConfig__init__

def FMBlockConfig__setstate__(self, state):
  state.setdefault('name', "FMBlock")
  state.setdefault('block_id', None)
  state.setdefault('input_feat_config', None)
  state.setdefault('type', None)
  self.__dict__ = state

FMBlockConfig.__getstate__ = lambda self: self.__dict__.copy()
FMBlockConfig.__setstate__ = FMBlockConfig__setstate__

all_structs.append(DotProcessorBlockConfig)
DotProcessorBlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, "DotProcessorBlock", 2, ), # 1
  (2, TType.I32, 'block_id', None, None, 2, ), # 2
  (3, TType.LIST, 'input_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'type', [BlockType, BlockType.thrift_spec, True], None, 2, ), # 4
)

DotProcessorBlockConfig.thrift_struct_annotations = {
}
DotProcessorBlockConfig.thrift_field_annotations = {
}

def DotProcessorBlockConfig__init__(self, name=DotProcessorBlockConfig.thrift_spec[1][4], block_id=None, input_feat_config=None, type=None,):
  self.name = name
  self.block_id = block_id
  self.input_feat_config = input_feat_config
  self.type = type

DotProcessorBlockConfig.__init__ = DotProcessorBlockConfig__init__

def DotProcessorBlockConfig__setstate__(self, state):
  state.setdefault('name', "DotProcessorBlock")
  state.setdefault('block_id', None)
  state.setdefault('input_feat_config', None)
  state.setdefault('type', None)
  self.__dict__ = state

DotProcessorBlockConfig.__getstate__ = lambda self: self.__dict__.copy()
DotProcessorBlockConfig.__setstate__ = DotProcessorBlockConfig__setstate__

all_structs.append(CatBlockConfig)
CatBlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, "CatBlock", 2, ), # 1
  (2, TType.I32, 'block_id', None, None, 2, ), # 2
  (3, TType.LIST, 'input_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'type', [BlockType, BlockType.thrift_spec, True], None, 2, ), # 4
)

CatBlockConfig.thrift_struct_annotations = {
}
CatBlockConfig.thrift_field_annotations = {
}

def CatBlockConfig__init__(self, name=CatBlockConfig.thrift_spec[1][4], block_id=None, input_feat_config=None, type=None,):
  self.name = name
  self.block_id = block_id
  self.input_feat_config = input_feat_config
  self.type = type

CatBlockConfig.__init__ = CatBlockConfig__init__

def CatBlockConfig__setstate__(self, state):
  state.setdefault('name', "CatBlock")
  state.setdefault('block_id', None)
  state.setdefault('input_feat_config', None)
  state.setdefault('type', None)
  self.__dict__ = state

CatBlockConfig.__getstate__ = lambda self: self.__dict__.copy()
CatBlockConfig.__setstate__ = CatBlockConfig__setstate__

all_structs.append(CINBlockConfig)
CINBlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, "CINBlock", 2, ), # 1
  (2, TType.I32, 'block_id', None, None, 2, ), # 2
  (3, TType.LIST, 'input_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'emb_config', [EmbedBlockType, EmbedBlockType.thrift_spec, False], None, 2, ), # 4
  (5, TType.LIST, 'arc', (TType.I32,None), None, 2, ), # 5
  (6, TType.BOOL, 'split_half', None, True, 2, ), # 6
)

CINBlockConfig.thrift_struct_annotations = {
}
CINBlockConfig.thrift_field_annotations = {
}

def CINBlockConfig__init__(self, name=CINBlockConfig.thrift_spec[1][4], block_id=None, input_feat_config=None, emb_config=None, arc=None, split_half=CINBlockConfig.thrift_spec[6][4],):
  self.name = name
  self.block_id = block_id
  self.input_feat_config = input_feat_config
  self.emb_config = emb_config
  self.arc = arc
  self.split_half = split_half

CINBlockConfig.__init__ = CINBlockConfig__init__

def CINBlockConfig__setstate__(self, state):
  state.setdefault('name', "CINBlock")
  state.setdefault('block_id', None)
  state.setdefault('input_feat_config', None)
  state.setdefault('emb_config', None)
  state.setdefault('arc', None)
  state.setdefault('split_half', True)
  self.__dict__ = state

CINBlockConfig.__getstate__ = lambda self: self.__dict__.copy()
CINBlockConfig.__setstate__ = CINBlockConfig__setstate__

all_structs.append(AttentionBlockConfig)
AttentionBlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, "AttentionBlock", 2, ), # 1
  (2, TType.I32, 'block_id', None, None, 2, ), # 2
  (3, TType.LIST, 'input_feat_config', (TType.STRUCT,[FeatSelectionConfig, FeatSelectionConfig.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'emb_config', [EmbedBlockType, EmbedBlockType.thrift_spec, False], None, 2, ), # 4
  (5, TType.I32, 'att_embed_dim', None, 10, 2, ), # 5
  (6, TType.I32, 'num_of_heads', None, 2, 2, ), # 6
  (7, TType.I32, 'num_of_layers', None, 1, 2, ), # 7
  (8, TType.FLOAT, 'dropout_prob', None, 0.00000, 2, ), # 8
  (9, TType.BOOL, 'use_res', None, True, 2, ), # 9
  (10, TType.BOOL, 'batchnorm', None, False, 2, ), # 10
)

AttentionBlockConfig.thrift_struct_annotations = {
}
AttentionBlockConfig.thrift_field_annotations = {
}

def AttentionBlockConfig__init__(self, name=AttentionBlockConfig.thrift_spec[1][4], block_id=None, input_feat_config=None, emb_config=None, att_embed_dim=AttentionBlockConfig.thrift_spec[5][4], num_of_heads=AttentionBlockConfig.thrift_spec[6][4], num_of_layers=AttentionBlockConfig.thrift_spec[7][4], dropout_prob=AttentionBlockConfig.thrift_spec[8][4], use_res=AttentionBlockConfig.thrift_spec[9][4], batchnorm=AttentionBlockConfig.thrift_spec[10][4],):
  self.name = name
  self.block_id = block_id
  self.input_feat_config = input_feat_config
  self.emb_config = emb_config
  self.att_embed_dim = att_embed_dim
  self.num_of_heads = num_of_heads
  self.num_of_layers = num_of_layers
  self.dropout_prob = dropout_prob
  self.use_res = use_res
  self.batchnorm = batchnorm

AttentionBlockConfig.__init__ = AttentionBlockConfig__init__

def AttentionBlockConfig__setstate__(self, state):
  state.setdefault('name', "AttentionBlock")
  state.setdefault('block_id', None)
  state.setdefault('input_feat_config', None)
  state.setdefault('emb_config', None)
  state.setdefault('att_embed_dim', 10)
  state.setdefault('num_of_heads', 2)
  state.setdefault('num_of_layers', 1)
  state.setdefault('dropout_prob', 0.00000)
  state.setdefault('use_res', True)
  state.setdefault('batchnorm', False)
  self.__dict__ = state

AttentionBlockConfig.__getstate__ = lambda self: self.__dict__.copy()
AttentionBlockConfig.__setstate__ = AttentionBlockConfig__setstate__

all_structs.append(BlockConfig)
BlockConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'mlp_block', [MLPBlockConfig, MLPBlockConfig.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'crossnet_block', [CrossNetBlockConfig, CrossNetBlockConfig.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'fm_block', [FMBlockConfig, FMBlockConfig.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'dotprocessor_block', [DotProcessorBlockConfig, DotProcessorBlockConfig.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'cat_block', [CatBlockConfig, CatBlockConfig.thrift_spec, False], None, 2, ), # 5
  (6, TType.STRUCT, 'cin_block', [CINBlockConfig, CINBlockConfig.thrift_spec, False], None, 2, ), # 6
  (7, TType.STRUCT, 'attention_block', [AttentionBlockConfig, AttentionBlockConfig.thrift_spec, False], None, 2, ), # 7
)

BlockConfig.thrift_struct_annotations = {
}
BlockConfig.thrift_field_annotations = {
}

def BlockConfig__init__(self, mlp_block=None, crossnet_block=None, fm_block=None, dotprocessor_block=None, cat_block=None, cin_block=None, attention_block=None,):
  self.field = 0
  self.value = None
  if mlp_block is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = mlp_block
  if crossnet_block is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = crossnet_block
  if fm_block is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = fm_block
  if dotprocessor_block is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = dotprocessor_block
  if cat_block is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = cat_block
  if cin_block is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = cin_block
  if attention_block is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = attention_block

BlockConfig.__init__ = BlockConfig__init__

fix_spec(all_structs)
del all_structs
