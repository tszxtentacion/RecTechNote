#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import block_config.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except ImportError:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MacroSearchSpaceType', 'DataFromFileConfig', 'DataConfig', 'MicroClose', 'MicroMLPConfig', 'MicroCINConfig', 'MicroAttentionConfig', 'MicroSearchSpaceType', 'InputDenseAsSparse', 'FeatureProcessingType', 'NASRecNetConfig', 'RandomSearcherConfig', 'EvolutionarySearcherConfig', 'SearcherConfig', 'ModelConfig', 'SGDOptimConfig', 'AdagradOptimConfig', 'SparseAdamOptimConfig', 'AdamOptimConfig', 'RMSpropOptimConfig', 'OptimConfig', 'SumPooling', 'AvgPooling', 'PoolingConfig', 'SparseFeatureItem', 'SparseFeatureConfig', 'DenseFeatureConfig', 'FeatureConfig', 'BCEWithLogitsLoss', 'BCELoss', 'MSELoss', 'LossConfig', 'LoggingConfig', 'TrainConfig', 'EvalConfig', 'CheckpointConfig', 'KoskiReaderConfig', 'PerformanceConfig']

class MacroSearchSpaceType:
  INPUT_DIFF = 1
  INPUT_GROUP = 2
  INPUT_DIFF_PRIOR = 3
  INPUT_ELASTIC_PRIOR = 4

  _VALUES_TO_NAMES = {
    1: "INPUT_DIFF",
    2: "INPUT_GROUP",
    3: "INPUT_DIFF_PRIOR",
    4: "INPUT_ELASTIC_PRIOR",
  }

  _NAMES_TO_VALUES = {
    "INPUT_DIFF": 1,
    "INPUT_GROUP": 2,
    "INPUT_DIFF_PRIOR": 3,
    "INPUT_ELASTIC_PRIOR": 4,
  }

class DataFromFileConfig:
  """
  Attributes:
   - data_file
   - batch_size
   - num_batches
   - splits
   - num_samples_meta
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data_file = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.batch_size = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_batches = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.splits = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = iprot.readFloat()
              self.splits.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readFloat()
              self.splits.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.num_samples_meta = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DataFromFileConfig')
    if self.data_file != None:
      oprot.writeFieldBegin('data_file', TType.STRING, 1)
      oprot.writeString(self.data_file.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data_file, bytes) else oprot.writeString(self.data_file)
      oprot.writeFieldEnd()
    if self.batch_size != None:
      oprot.writeFieldBegin('batch_size', TType.I32, 2)
      oprot.writeI32(self.batch_size)
      oprot.writeFieldEnd()
    if self.num_batches != None:
      oprot.writeFieldBegin('num_batches', TType.I32, 3)
      oprot.writeI32(self.num_batches)
      oprot.writeFieldEnd()
    if self.splits != None:
      oprot.writeFieldBegin('splits', TType.LIST, 4)
      oprot.writeListBegin(TType.FLOAT, len(self.splits))
      for iter7 in self.splits:
        oprot.writeFloat(iter7)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.num_samples_meta != None:
      oprot.writeFieldBegin('num_samples_meta', TType.I32, 5)
      oprot.writeI32(self.num_samples_meta)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data_file is not None:
      value = pprint.pformat(self.data_file, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data_file=%s' % (value))
    if self.batch_size is not None:
      value = pprint.pformat(self.batch_size, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    batch_size=%s' % (value))
    if self.num_batches is not None:
      value = pprint.pformat(self.num_batches, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_batches=%s' % (value))
    if self.splits is not None:
      value = pprint.pformat(self.splits, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    splits=%s' % (value))
    if self.num_samples_meta is not None:
      value = pprint.pformat(self.num_samples_meta, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_samples_meta=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DataConfig(object):
  """
  Attributes:
   - from_file
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  FROM_FILE = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_from_file(self):
    assert self.field == 1
    return self.value

  def set_from_file(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('from_file', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          from_file = DataFromFileConfig()
          from_file.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_from_file(from_file)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('DataConfig')
    if self.field == 1:
      oprot.writeFieldBegin('from_file', TType.STRUCT, 1)
      from_file = self.value
      from_file.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MicroClose:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MicroClose')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MicroMLPConfig:
  """
  Attributes:
   - arc
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.arc = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = iprot.readI32()
              self.arc.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = iprot.readI32()
              self.arc.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MicroMLPConfig')
    if self.arc != None:
      oprot.writeFieldBegin('arc', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.arc))
      for iter15 in self.arc:
        oprot.writeI32(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.arc is not None:
      value = pprint.pformat(self.arc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    arc=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MicroCINConfig:
  """
  Attributes:
   - arc
   - num_of_layers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.arc = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _elem21 = iprot.readI32()
              self.arc.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = iprot.readI32()
              self.arc.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.num_of_layers = []
          (_etype26, _size23) = iprot.readListBegin()
          if _size23 >= 0:
            for _i27 in six.moves.range(_size23):
              _elem28 = iprot.readI32()
              self.num_of_layers.append(_elem28)
          else: 
            while iprot.peekList():
              _elem29 = iprot.readI32()
              self.num_of_layers.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MicroCINConfig')
    if self.arc != None:
      oprot.writeFieldBegin('arc', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.arc))
      for iter30 in self.arc:
        oprot.writeI32(iter30)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.num_of_layers != None:
      oprot.writeFieldBegin('num_of_layers', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.num_of_layers))
      for iter31 in self.num_of_layers:
        oprot.writeI32(iter31)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.arc is not None:
      value = pprint.pformat(self.arc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    arc=%s' % (value))
    if self.num_of_layers is not None:
      value = pprint.pformat(self.num_of_layers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_of_layers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MicroAttentionConfig:
  """
  Attributes:
   - num_of_layers
   - num_of_heads
   - att_embed_dim
   - dropout_prob
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.num_of_layers = []
          (_etype35, _size32) = iprot.readListBegin()
          if _size32 >= 0:
            for _i36 in six.moves.range(_size32):
              _elem37 = iprot.readI32()
              self.num_of_layers.append(_elem37)
          else: 
            while iprot.peekList():
              _elem38 = iprot.readI32()
              self.num_of_layers.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.num_of_heads = []
          (_etype42, _size39) = iprot.readListBegin()
          if _size39 >= 0:
            for _i43 in six.moves.range(_size39):
              _elem44 = iprot.readI32()
              self.num_of_heads.append(_elem44)
          else: 
            while iprot.peekList():
              _elem45 = iprot.readI32()
              self.num_of_heads.append(_elem45)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.att_embed_dim = []
          (_etype49, _size46) = iprot.readListBegin()
          if _size46 >= 0:
            for _i50 in six.moves.range(_size46):
              _elem51 = iprot.readI32()
              self.att_embed_dim.append(_elem51)
          else: 
            while iprot.peekList():
              _elem52 = iprot.readI32()
              self.att_embed_dim.append(_elem52)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.dropout_prob = []
          (_etype56, _size53) = iprot.readListBegin()
          if _size53 >= 0:
            for _i57 in six.moves.range(_size53):
              _elem58 = iprot.readFloat()
              self.dropout_prob.append(_elem58)
          else: 
            while iprot.peekList():
              _elem59 = iprot.readFloat()
              self.dropout_prob.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MicroAttentionConfig')
    if self.num_of_layers != None:
      oprot.writeFieldBegin('num_of_layers', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.num_of_layers))
      for iter60 in self.num_of_layers:
        oprot.writeI32(iter60)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.num_of_heads != None:
      oprot.writeFieldBegin('num_of_heads', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.num_of_heads))
      for iter61 in self.num_of_heads:
        oprot.writeI32(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.att_embed_dim != None:
      oprot.writeFieldBegin('att_embed_dim', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.att_embed_dim))
      for iter62 in self.att_embed_dim:
        oprot.writeI32(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dropout_prob != None:
      oprot.writeFieldBegin('dropout_prob', TType.LIST, 4)
      oprot.writeListBegin(TType.FLOAT, len(self.dropout_prob))
      for iter63 in self.dropout_prob:
        oprot.writeFloat(iter63)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.num_of_layers is not None:
      value = pprint.pformat(self.num_of_layers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_of_layers=%s' % (value))
    if self.num_of_heads is not None:
      value = pprint.pformat(self.num_of_heads, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_of_heads=%s' % (value))
    if self.att_embed_dim is not None:
      value = pprint.pformat(self.att_embed_dim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    att_embed_dim=%s' % (value))
    if self.dropout_prob is not None:
      value = pprint.pformat(self.dropout_prob, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dropout_prob=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MicroSearchSpaceType(object):
  """
  Attributes:
   - close
   - micro_mlp
   - micro_cin
   - micro_attention
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  CLOSE = 1
  MICRO_MLP = 2
  MICRO_CIN = 3
  MICRO_ATTENTION = 4
  
  @staticmethod
  def isUnion():
    return True

  def get_close(self):
    assert self.field == 1
    return self.value

  def get_micro_mlp(self):
    assert self.field == 2
    return self.value

  def get_micro_cin(self):
    assert self.field == 3
    return self.value

  def get_micro_attention(self):
    assert self.field == 4
    return self.value

  def set_close(self, value):
    self.field = 1
    self.value = value

  def set_micro_mlp(self, value):
    self.field = 2
    self.value = value

  def set_micro_cin(self, value):
    self.field = 3
    self.value = value

  def set_micro_attention(self, value):
    self.field = 4
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('close', value)
    if self.field == 2:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('micro_mlp', value)
    if self.field == 3:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('micro_cin', value)
    if self.field == 4:
      padding = ' ' * 16
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('micro_attention', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          close = MicroClose()
          close.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_close(close)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          micro_mlp = MicroMLPConfig()
          micro_mlp.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_micro_mlp(micro_mlp)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          micro_cin = MicroCINConfig()
          micro_cin.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_micro_cin(micro_cin)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          micro_attention = MicroAttentionConfig()
          micro_attention.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_micro_attention(micro_attention)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MicroSearchSpaceType')
    if self.field == 1:
      oprot.writeFieldBegin('close', TType.STRUCT, 1)
      close = self.value
      close.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('micro_mlp', TType.STRUCT, 2)
      micro_mlp = self.value
      micro_mlp.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('micro_cin', TType.STRUCT, 3)
      micro_cin = self.value
      micro_cin.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('micro_attention', TType.STRUCT, 4)
      micro_attention = self.value
      micro_attention.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InputDenseAsSparse:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InputDenseAsSparse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class FeatureProcessingType(object):
  """
  Attributes:
   - idasp
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  IDASP = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_idasp(self):
    assert self.field == 1
    return self.value

  def set_idasp(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('idasp', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          idasp = InputDenseAsSparse()
          idasp.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_idasp(idasp)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('FeatureProcessingType')
    if self.field == 1:
      oprot.writeFieldBegin('idasp', TType.STRUCT, 1)
      idasp = self.value
      idasp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NASRecNetConfig:
  """
  Attributes:
   - block_configs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.block_configs = []
          (_etype67, _size64) = iprot.readListBegin()
          if _size64 >= 0:
            for _i68 in six.moves.range(_size64):
              _elem69 = block_config.ttypes.BlockConfig()
              _elem69.read(iprot)
              self.block_configs.append(_elem69)
          else: 
            while iprot.peekList():
              _elem70 = block_config.ttypes.BlockConfig()
              _elem70.read(iprot)
              self.block_configs.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NASRecNetConfig')
    if self.block_configs != None:
      oprot.writeFieldBegin('block_configs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.block_configs))
      for iter71 in self.block_configs:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.block_configs is not None:
      value = pprint.pformat(self.block_configs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_configs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RandomSearcherConfig:
  """
  Attributes:
   - max_num_block
   - block_types
   - macro_space_type
   - micro_space_types
   - feature_processing_type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.max_num_block = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.block_types = []
          (_etype75, _size72) = iprot.readListBegin()
          if _size72 >= 0:
            for _i76 in six.moves.range(_size72):
              _elem77 = iprot.readI32()
              self.block_types.append(_elem77)
          else: 
            while iprot.peekList():
              _elem78 = iprot.readI32()
              self.block_types.append(_elem78)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.macro_space_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.micro_space_types = []
          (_etype82, _size79) = iprot.readListBegin()
          if _size79 >= 0:
            for _i83 in six.moves.range(_size79):
              _elem84 = MicroSearchSpaceType()
              _elem84.read(iprot)
              self.micro_space_types.append(_elem84)
          else: 
            while iprot.peekList():
              _elem85 = MicroSearchSpaceType()
              _elem85.read(iprot)
              self.micro_space_types.append(_elem85)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.feature_processing_type = []
          (_etype89, _size86) = iprot.readListBegin()
          if _size86 >= 0:
            for _i90 in six.moves.range(_size86):
              _elem91 = FeatureProcessingType()
              _elem91.read(iprot)
              self.feature_processing_type.append(_elem91)
          else: 
            while iprot.peekList():
              _elem92 = FeatureProcessingType()
              _elem92.read(iprot)
              self.feature_processing_type.append(_elem92)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RandomSearcherConfig')
    if self.max_num_block != None:
      oprot.writeFieldBegin('max_num_block', TType.I32, 1)
      oprot.writeI32(self.max_num_block)
      oprot.writeFieldEnd()
    if self.block_types != None:
      oprot.writeFieldBegin('block_types', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.block_types))
      for iter93 in self.block_types:
        oprot.writeI32(iter93)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.macro_space_type != None:
      oprot.writeFieldBegin('macro_space_type', TType.I32, 3)
      oprot.writeI32(self.macro_space_type)
      oprot.writeFieldEnd()
    if self.micro_space_types != None:
      oprot.writeFieldBegin('micro_space_types', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.micro_space_types))
      for iter94 in self.micro_space_types:
        iter94.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.feature_processing_type != None:
      oprot.writeFieldBegin('feature_processing_type', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.feature_processing_type))
      for iter95 in self.feature_processing_type:
        iter95.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.max_num_block is not None:
      value = pprint.pformat(self.max_num_block, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_num_block=%s' % (value))
    if self.block_types is not None:
      value = pprint.pformat(self.block_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_types=%s' % (value))
    if self.macro_space_type is not None:
      value = pprint.pformat(self.macro_space_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    macro_space_type=%s' % (value))
    if self.micro_space_types is not None:
      value = pprint.pformat(self.micro_space_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    micro_space_types=%s' % (value))
    if self.feature_processing_type is not None:
      value = pprint.pformat(self.feature_processing_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    feature_processing_type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EvolutionarySearcherConfig:
  """
  Attributes:
   - max_num_block
   - block_types
   - population_size
   - candidate_size
   - macro_space_type
   - micro_space_types
   - feature_processing_type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.max_num_block = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.block_types = []
          (_etype99, _size96) = iprot.readListBegin()
          if _size96 >= 0:
            for _i100 in six.moves.range(_size96):
              _elem101 = iprot.readI32()
              self.block_types.append(_elem101)
          else: 
            while iprot.peekList():
              _elem102 = iprot.readI32()
              self.block_types.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.population_size = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.candidate_size = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.macro_space_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.micro_space_types = []
          (_etype106, _size103) = iprot.readListBegin()
          if _size103 >= 0:
            for _i107 in six.moves.range(_size103):
              _elem108 = MicroSearchSpaceType()
              _elem108.read(iprot)
              self.micro_space_types.append(_elem108)
          else: 
            while iprot.peekList():
              _elem109 = MicroSearchSpaceType()
              _elem109.read(iprot)
              self.micro_space_types.append(_elem109)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.feature_processing_type = []
          (_etype113, _size110) = iprot.readListBegin()
          if _size110 >= 0:
            for _i114 in six.moves.range(_size110):
              _elem115 = FeatureProcessingType()
              _elem115.read(iprot)
              self.feature_processing_type.append(_elem115)
          else: 
            while iprot.peekList():
              _elem116 = FeatureProcessingType()
              _elem116.read(iprot)
              self.feature_processing_type.append(_elem116)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EvolutionarySearcherConfig')
    if self.max_num_block != None:
      oprot.writeFieldBegin('max_num_block', TType.I32, 1)
      oprot.writeI32(self.max_num_block)
      oprot.writeFieldEnd()
    if self.block_types != None:
      oprot.writeFieldBegin('block_types', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.block_types))
      for iter117 in self.block_types:
        oprot.writeI32(iter117)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.population_size != None:
      oprot.writeFieldBegin('population_size', TType.I32, 3)
      oprot.writeI32(self.population_size)
      oprot.writeFieldEnd()
    if self.candidate_size != None:
      oprot.writeFieldBegin('candidate_size', TType.I32, 4)
      oprot.writeI32(self.candidate_size)
      oprot.writeFieldEnd()
    if self.macro_space_type != None:
      oprot.writeFieldBegin('macro_space_type', TType.I32, 5)
      oprot.writeI32(self.macro_space_type)
      oprot.writeFieldEnd()
    if self.micro_space_types != None:
      oprot.writeFieldBegin('micro_space_types', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.micro_space_types))
      for iter118 in self.micro_space_types:
        iter118.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.feature_processing_type != None:
      oprot.writeFieldBegin('feature_processing_type', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.feature_processing_type))
      for iter119 in self.feature_processing_type:
        iter119.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.max_num_block is not None:
      value = pprint.pformat(self.max_num_block, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_num_block=%s' % (value))
    if self.block_types is not None:
      value = pprint.pformat(self.block_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    block_types=%s' % (value))
    if self.population_size is not None:
      value = pprint.pformat(self.population_size, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    population_size=%s' % (value))
    if self.candidate_size is not None:
      value = pprint.pformat(self.candidate_size, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    candidate_size=%s' % (value))
    if self.macro_space_type is not None:
      value = pprint.pformat(self.macro_space_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    macro_space_type=%s' % (value))
    if self.micro_space_types is not None:
      value = pprint.pformat(self.micro_space_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    micro_space_types=%s' % (value))
    if self.feature_processing_type is not None:
      value = pprint.pformat(self.feature_processing_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    feature_processing_type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SearcherConfig(object):
  """
  Attributes:
   - random_searcher
   - evolutionary_searcher
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  RANDOM_SEARCHER = 1
  EVOLUTIONARY_SEARCHER = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_random_searcher(self):
    assert self.field == 1
    return self.value

  def get_evolutionary_searcher(self):
    assert self.field == 2
    return self.value

  def set_random_searcher(self, value):
    self.field = 1
    self.value = value

  def set_evolutionary_searcher(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 16
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('random_searcher', value)
    if self.field == 2:
      padding = ' ' * 22
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('evolutionary_searcher', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          random_searcher = RandomSearcherConfig()
          random_searcher.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_random_searcher(random_searcher)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          evolutionary_searcher = EvolutionarySearcherConfig()
          evolutionary_searcher.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_evolutionary_searcher(evolutionary_searcher)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('SearcherConfig')
    if self.field == 1:
      oprot.writeFieldBegin('random_searcher', TType.STRUCT, 1)
      random_searcher = self.value
      random_searcher.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('evolutionary_searcher', TType.STRUCT, 2)
      evolutionary_searcher = self.value
      evolutionary_searcher.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ModelConfig(object):
  """
  Attributes:
   - nasrec_net
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  NASREC_NET = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_nasrec_net(self):
    assert self.field == 1
    return self.value

  def set_nasrec_net(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('nasrec_net', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          nasrec_net = NASRecNetConfig()
          nasrec_net.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_nasrec_net(nasrec_net)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('ModelConfig')
    if self.field == 1:
      oprot.writeFieldBegin('nasrec_net', TType.STRUCT, 1)
      nasrec_net = self.value
      nasrec_net.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SGDOptimConfig:
  """
  Attributes:
   - lr
   - momentum
   - dampening
   - nesterov
   - weight_decay
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.lr = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.FLOAT:
          self.momentum = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.FLOAT:
          self.dampening = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.nesterov = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.FLOAT:
          self.weight_decay = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SGDOptimConfig')
    if self.lr != None:
      oprot.writeFieldBegin('lr', TType.FLOAT, 1)
      oprot.writeFloat(self.lr)
      oprot.writeFieldEnd()
    if self.momentum != None:
      oprot.writeFieldBegin('momentum', TType.FLOAT, 2)
      oprot.writeFloat(self.momentum)
      oprot.writeFieldEnd()
    if self.dampening != None:
      oprot.writeFieldBegin('dampening', TType.FLOAT, 3)
      oprot.writeFloat(self.dampening)
      oprot.writeFieldEnd()
    if self.nesterov != None:
      oprot.writeFieldBegin('nesterov', TType.BOOL, 4)
      oprot.writeBool(self.nesterov)
      oprot.writeFieldEnd()
    if self.weight_decay != None:
      oprot.writeFieldBegin('weight_decay', TType.FLOAT, 5)
      oprot.writeFloat(self.weight_decay)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.lr is not None:
      value = pprint.pformat(self.lr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lr=%s' % (value))
    if self.momentum is not None:
      value = pprint.pformat(self.momentum, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    momentum=%s' % (value))
    if self.dampening is not None:
      value = pprint.pformat(self.dampening, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dampening=%s' % (value))
    if self.nesterov is not None:
      value = pprint.pformat(self.nesterov, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nesterov=%s' % (value))
    if self.weight_decay is not None:
      value = pprint.pformat(self.weight_decay, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    weight_decay=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdagradOptimConfig:
  """
  Attributes:
   - lr
   - lr_decay
   - weight_decay
   - initial_accumulator_value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.lr = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.FLOAT:
          self.lr_decay = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.FLOAT:
          self.weight_decay = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.FLOAT:
          self.initial_accumulator_value = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdagradOptimConfig')
    if self.lr != None:
      oprot.writeFieldBegin('lr', TType.FLOAT, 1)
      oprot.writeFloat(self.lr)
      oprot.writeFieldEnd()
    if self.lr_decay != None:
      oprot.writeFieldBegin('lr_decay', TType.FLOAT, 2)
      oprot.writeFloat(self.lr_decay)
      oprot.writeFieldEnd()
    if self.weight_decay != None:
      oprot.writeFieldBegin('weight_decay', TType.FLOAT, 3)
      oprot.writeFloat(self.weight_decay)
      oprot.writeFieldEnd()
    if self.initial_accumulator_value != None:
      oprot.writeFieldBegin('initial_accumulator_value', TType.FLOAT, 4)
      oprot.writeFloat(self.initial_accumulator_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.lr is not None:
      value = pprint.pformat(self.lr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lr=%s' % (value))
    if self.lr_decay is not None:
      value = pprint.pformat(self.lr_decay, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lr_decay=%s' % (value))
    if self.weight_decay is not None:
      value = pprint.pformat(self.weight_decay, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    weight_decay=%s' % (value))
    if self.initial_accumulator_value is not None:
      value = pprint.pformat(self.initial_accumulator_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    initial_accumulator_value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SparseAdamOptimConfig:
  """
  Attributes:
   - lr
   - betas0
   - betas1
   - eps
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.lr = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.FLOAT:
          self.betas0 = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.FLOAT:
          self.betas1 = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.FLOAT:
          self.eps = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparseAdamOptimConfig')
    if self.lr != None:
      oprot.writeFieldBegin('lr', TType.FLOAT, 1)
      oprot.writeFloat(self.lr)
      oprot.writeFieldEnd()
    if self.betas0 != None:
      oprot.writeFieldBegin('betas0', TType.FLOAT, 2)
      oprot.writeFloat(self.betas0)
      oprot.writeFieldEnd()
    if self.betas1 != None:
      oprot.writeFieldBegin('betas1', TType.FLOAT, 3)
      oprot.writeFloat(self.betas1)
      oprot.writeFieldEnd()
    if self.eps != None:
      oprot.writeFieldBegin('eps', TType.FLOAT, 4)
      oprot.writeFloat(self.eps)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.lr is not None:
      value = pprint.pformat(self.lr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lr=%s' % (value))
    if self.betas0 is not None:
      value = pprint.pformat(self.betas0, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    betas0=%s' % (value))
    if self.betas1 is not None:
      value = pprint.pformat(self.betas1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    betas1=%s' % (value))
    if self.eps is not None:
      value = pprint.pformat(self.eps, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    eps=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdamOptimConfig:
  """
  Attributes:
   - lr
   - amsgrad
   - weight_decay
   - betas0
   - betas1
   - eps
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.lr = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.amsgrad = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.FLOAT:
          self.weight_decay = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.FLOAT:
          self.betas0 = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.FLOAT:
          self.betas1 = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.eps = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdamOptimConfig')
    if self.lr != None:
      oprot.writeFieldBegin('lr', TType.FLOAT, 1)
      oprot.writeFloat(self.lr)
      oprot.writeFieldEnd()
    if self.amsgrad != None:
      oprot.writeFieldBegin('amsgrad', TType.BOOL, 2)
      oprot.writeBool(self.amsgrad)
      oprot.writeFieldEnd()
    if self.weight_decay != None:
      oprot.writeFieldBegin('weight_decay', TType.FLOAT, 3)
      oprot.writeFloat(self.weight_decay)
      oprot.writeFieldEnd()
    if self.betas0 != None:
      oprot.writeFieldBegin('betas0', TType.FLOAT, 4)
      oprot.writeFloat(self.betas0)
      oprot.writeFieldEnd()
    if self.betas1 != None:
      oprot.writeFieldBegin('betas1', TType.FLOAT, 5)
      oprot.writeFloat(self.betas1)
      oprot.writeFieldEnd()
    if self.eps != None:
      oprot.writeFieldBegin('eps', TType.FLOAT, 6)
      oprot.writeFloat(self.eps)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.lr is not None:
      value = pprint.pformat(self.lr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lr=%s' % (value))
    if self.amsgrad is not None:
      value = pprint.pformat(self.amsgrad, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    amsgrad=%s' % (value))
    if self.weight_decay is not None:
      value = pprint.pformat(self.weight_decay, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    weight_decay=%s' % (value))
    if self.betas0 is not None:
      value = pprint.pformat(self.betas0, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    betas0=%s' % (value))
    if self.betas1 is not None:
      value = pprint.pformat(self.betas1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    betas1=%s' % (value))
    if self.eps is not None:
      value = pprint.pformat(self.eps, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    eps=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RMSpropOptimConfig:
  """
  Attributes:
   - lr
   - alpha
   - weight_decay
   - momentum
   - centered
   - eps
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.lr = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.FLOAT:
          self.alpha = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.FLOAT:
          self.weight_decay = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.FLOAT:
          self.momentum = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.centered = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.eps = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RMSpropOptimConfig')
    if self.lr != None:
      oprot.writeFieldBegin('lr', TType.FLOAT, 1)
      oprot.writeFloat(self.lr)
      oprot.writeFieldEnd()
    if self.alpha != None:
      oprot.writeFieldBegin('alpha', TType.FLOAT, 2)
      oprot.writeFloat(self.alpha)
      oprot.writeFieldEnd()
    if self.weight_decay != None:
      oprot.writeFieldBegin('weight_decay', TType.FLOAT, 3)
      oprot.writeFloat(self.weight_decay)
      oprot.writeFieldEnd()
    if self.momentum != None:
      oprot.writeFieldBegin('momentum', TType.FLOAT, 4)
      oprot.writeFloat(self.momentum)
      oprot.writeFieldEnd()
    if self.centered != None:
      oprot.writeFieldBegin('centered', TType.BOOL, 5)
      oprot.writeBool(self.centered)
      oprot.writeFieldEnd()
    if self.eps != None:
      oprot.writeFieldBegin('eps', TType.FLOAT, 6)
      oprot.writeFloat(self.eps)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.lr is not None:
      value = pprint.pformat(self.lr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lr=%s' % (value))
    if self.alpha is not None:
      value = pprint.pformat(self.alpha, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alpha=%s' % (value))
    if self.weight_decay is not None:
      value = pprint.pformat(self.weight_decay, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    weight_decay=%s' % (value))
    if self.momentum is not None:
      value = pprint.pformat(self.momentum, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    momentum=%s' % (value))
    if self.centered is not None:
      value = pprint.pformat(self.centered, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    centered=%s' % (value))
    if self.eps is not None:
      value = pprint.pformat(self.eps, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    eps=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class OptimConfig(object):
  """
  Attributes:
   - sgd
   - adagrad
   - sparse_adam
   - adam
   - rmsprop
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  SGD = 1
  ADAGRAD = 2
  SPARSE_ADAM = 3
  ADAM = 4
  RMSPROP = 5
  
  @staticmethod
  def isUnion():
    return True

  def get_sgd(self):
    assert self.field == 1
    return self.value

  def get_adagrad(self):
    assert self.field == 2
    return self.value

  def get_sparse_adam(self):
    assert self.field == 3
    return self.value

  def get_adam(self):
    assert self.field == 4
    return self.value

  def get_rmsprop(self):
    assert self.field == 5
    return self.value

  def set_sgd(self, value):
    self.field = 1
    self.value = value

  def set_adagrad(self, value):
    self.field = 2
    self.value = value

  def set_sparse_adam(self, value):
    self.field = 3
    self.value = value

  def set_adam(self, value):
    self.field = 4
    self.value = value

  def set_rmsprop(self, value):
    self.field = 5
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('sgd', value)
    if self.field == 2:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('adagrad', value)
    if self.field == 3:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('sparse_adam', value)
    if self.field == 4:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('adam', value)
    if self.field == 5:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('rmsprop', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          sgd = SGDOptimConfig()
          sgd.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_sgd(sgd)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          adagrad = AdagradOptimConfig()
          adagrad.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_adagrad(adagrad)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          sparse_adam = SparseAdamOptimConfig()
          sparse_adam.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_sparse_adam(sparse_adam)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          adam = AdamOptimConfig()
          adam.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_adam(adam)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          rmsprop = RMSpropOptimConfig()
          rmsprop.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_rmsprop(rmsprop)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('OptimConfig')
    if self.field == 1:
      oprot.writeFieldBegin('sgd', TType.STRUCT, 1)
      sgd = self.value
      sgd.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('adagrad', TType.STRUCT, 2)
      adagrad = self.value
      adagrad.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('sparse_adam', TType.STRUCT, 3)
      sparse_adam = self.value
      sparse_adam.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('adam', TType.STRUCT, 4)
      adam = self.value
      adam.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('rmsprop', TType.STRUCT, 5)
      rmsprop = self.value
      rmsprop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SumPooling:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SumPooling')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AvgPooling:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AvgPooling')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PoolingConfig(object):
  """
  Attributes:
   - sum
   - avg
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  SUM = 1
  AVG = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_sum(self):
    assert self.field == 1
    return self.value

  def get_avg(self):
    assert self.field == 2
    return self.value

  def set_sum(self, value):
    self.field = 1
    self.value = value

  def set_avg(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('sum', value)
    if self.field == 2:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('avg', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          sum = SumPooling()
          sum.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_sum(sum)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          avg = AvgPooling()
          avg.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_avg(avg)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('PoolingConfig')
    if self.field == 1:
      oprot.writeFieldBegin('sum', TType.STRUCT, 1)
      sum = self.value
      sum.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('avg', TType.STRUCT, 2)
      avg = self.value
      avg.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SparseFeatureItem:
  """
  Attributes:
   - name
   - hash_size
   - embed_dim
   - optim
   - pooling
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.hash_size = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.embed_dim = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.optim = OptimConfig()
          self.optim.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.pooling = PoolingConfig()
          self.pooling.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparseFeatureItem')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.hash_size != None:
      oprot.writeFieldBegin('hash_size', TType.I32, 2)
      oprot.writeI32(self.hash_size)
      oprot.writeFieldEnd()
    if self.embed_dim != None:
      oprot.writeFieldBegin('embed_dim', TType.I32, 3)
      oprot.writeI32(self.embed_dim)
      oprot.writeFieldEnd()
    if self.optim != None:
      oprot.writeFieldBegin('optim', TType.STRUCT, 4)
      self.optim.write(oprot)
      oprot.writeFieldEnd()
    if self.pooling != None:
      oprot.writeFieldBegin('pooling', TType.STRUCT, 5)
      self.pooling.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.hash_size is not None:
      value = pprint.pformat(self.hash_size, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hash_size=%s' % (value))
    if self.embed_dim is not None:
      value = pprint.pformat(self.embed_dim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    embed_dim=%s' % (value))
    if self.optim is not None:
      value = pprint.pformat(self.optim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optim=%s' % (value))
    if self.pooling is not None:
      value = pprint.pformat(self.pooling, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    pooling=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SparseFeatureConfig:
  """
  Attributes:
   - features
   - embed_dim
   - optim
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.features = []
          (_etype123, _size120) = iprot.readListBegin()
          if _size120 >= 0:
            for _i124 in six.moves.range(_size120):
              _elem125 = SparseFeatureItem()
              _elem125.read(iprot)
              self.features.append(_elem125)
          else: 
            while iprot.peekList():
              _elem126 = SparseFeatureItem()
              _elem126.read(iprot)
              self.features.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.embed_dim = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.optim = OptimConfig()
          self.optim.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparseFeatureConfig')
    if self.features != None:
      oprot.writeFieldBegin('features', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.features))
      for iter127 in self.features:
        iter127.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.embed_dim != None:
      oprot.writeFieldBegin('embed_dim', TType.I32, 2)
      oprot.writeI32(self.embed_dim)
      oprot.writeFieldEnd()
    if self.optim != None:
      oprot.writeFieldBegin('optim', TType.STRUCT, 3)
      self.optim.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.features is not None:
      value = pprint.pformat(self.features, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    features=%s' % (value))
    if self.embed_dim is not None:
      value = pprint.pformat(self.embed_dim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    embed_dim=%s' % (value))
    if self.optim is not None:
      value = pprint.pformat(self.optim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optim=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DenseFeatureConfig:
  """
  Attributes:
   - features
   - optim
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.features = []
          (_etype131, _size128) = iprot.readListBegin()
          if _size128 >= 0:
            for _i132 in six.moves.range(_size128):
              _elem133 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.features.append(_elem133)
          else: 
            while iprot.peekList():
              _elem134 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.features.append(_elem134)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.optim = OptimConfig()
          self.optim.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DenseFeatureConfig')
    if self.features != None:
      oprot.writeFieldBegin('features', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.features))
      for iter135 in self.features:
        oprot.writeString(iter135.encode('utf-8')) if UTF8STRINGS and not isinstance(iter135, bytes) else oprot.writeString(iter135)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optim != None:
      oprot.writeFieldBegin('optim', TType.STRUCT, 2)
      self.optim.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.features is not None:
      value = pprint.pformat(self.features, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    features=%s' % (value))
    if self.optim is not None:
      value = pprint.pformat(self.optim, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optim=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class FeatureConfig:
  """
  Attributes:
   - dense
   - sparse
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dense = DenseFeatureConfig()
          self.dense.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sparse = SparseFeatureConfig()
          self.sparse.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FeatureConfig')
    if self.dense != None:
      oprot.writeFieldBegin('dense', TType.STRUCT, 1)
      self.dense.write(oprot)
      oprot.writeFieldEnd()
    if self.sparse != None:
      oprot.writeFieldBegin('sparse', TType.STRUCT, 2)
      self.sparse.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.dense is not None:
      value = pprint.pformat(self.dense, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dense=%s' % (value))
    if self.sparse is not None:
      value = pprint.pformat(self.sparse, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sparse=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BCEWithLogitsLoss:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BCEWithLogitsLoss')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BCELoss:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BCELoss')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MSELoss:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MSELoss')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LossConfig(object):
  """
  Attributes:
   - bcewithlogits
   - bce
   - mse
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  BCEWITHLOGITS = 1
  BCE = 2
  MSE = 3
  
  @staticmethod
  def isUnion():
    return True

  def get_bcewithlogits(self):
    assert self.field == 1
    return self.value

  def get_bce(self):
    assert self.field == 2
    return self.value

  def get_mse(self):
    assert self.field == 3
    return self.value

  def set_bcewithlogits(self, value):
    self.field = 1
    self.value = value

  def set_bce(self, value):
    self.field = 2
    self.value = value

  def set_mse(self, value):
    self.field = 3
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 14
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bcewithlogits', value)
    if self.field == 2:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bce', value)
    if self.field == 3:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mse', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          bcewithlogits = BCEWithLogitsLoss()
          bcewithlogits.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_bcewithlogits(bcewithlogits)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          bce = BCELoss()
          bce.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_bce(bce)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          mse = MSELoss()
          mse.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_mse(mse)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('LossConfig')
    if self.field == 1:
      oprot.writeFieldBegin('bcewithlogits', TType.STRUCT, 1)
      bcewithlogits = self.value
      bcewithlogits.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('bce', TType.STRUCT, 2)
      bce = self.value
      bce.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('mse', TType.STRUCT, 3)
      mse = self.value
      mse.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoggingConfig:
  """
  Attributes:
   - log_freq
   - tb_log_freq
   - tb_log_model_weight_hist
   - tb_log_pr_curve_batch
   - tb_log_model_weight_filter_regex
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.log_freq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.tb_log_freq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.tb_log_model_weight_hist = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.tb_log_pr_curve_batch = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.tb_log_model_weight_filter_regex = []
          (_etype139, _size136) = iprot.readListBegin()
          if _size136 >= 0:
            for _i140 in six.moves.range(_size136):
              _elem141 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.tb_log_model_weight_filter_regex.append(_elem141)
          else: 
            while iprot.peekList():
              _elem142 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.tb_log_model_weight_filter_regex.append(_elem142)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LoggingConfig')
    if self.log_freq != None:
      oprot.writeFieldBegin('log_freq', TType.I32, 1)
      oprot.writeI32(self.log_freq)
      oprot.writeFieldEnd()
    if self.tb_log_freq != None:
      oprot.writeFieldBegin('tb_log_freq', TType.I32, 2)
      oprot.writeI32(self.tb_log_freq)
      oprot.writeFieldEnd()
    if self.tb_log_model_weight_hist != None:
      oprot.writeFieldBegin('tb_log_model_weight_hist', TType.BOOL, 3)
      oprot.writeBool(self.tb_log_model_weight_hist)
      oprot.writeFieldEnd()
    if self.tb_log_pr_curve_batch != None:
      oprot.writeFieldBegin('tb_log_pr_curve_batch', TType.BOOL, 4)
      oprot.writeBool(self.tb_log_pr_curve_batch)
      oprot.writeFieldEnd()
    if self.tb_log_model_weight_filter_regex != None:
      oprot.writeFieldBegin('tb_log_model_weight_filter_regex', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.tb_log_model_weight_filter_regex))
      for iter143 in self.tb_log_model_weight_filter_regex:
        oprot.writeString(iter143.encode('utf-8')) if UTF8STRINGS and not isinstance(iter143, bytes) else oprot.writeString(iter143)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.log_freq is not None:
      value = pprint.pformat(self.log_freq, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_freq=%s' % (value))
    if self.tb_log_freq is not None:
      value = pprint.pformat(self.tb_log_freq, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tb_log_freq=%s' % (value))
    if self.tb_log_model_weight_hist is not None:
      value = pprint.pformat(self.tb_log_model_weight_hist, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tb_log_model_weight_hist=%s' % (value))
    if self.tb_log_pr_curve_batch is not None:
      value = pprint.pformat(self.tb_log_pr_curve_batch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tb_log_pr_curve_batch=%s' % (value))
    if self.tb_log_model_weight_filter_regex is not None:
      value = pprint.pformat(self.tb_log_model_weight_filter_regex, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tb_log_model_weight_filter_regex=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TrainConfig:
  """
  Attributes:
   - logging_config
   - nepochs
   - early_stop_on_val_loss
   - loss
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.logging_config = LoggingConfig()
          self.logging_config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.nepochs = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.early_stop_on_val_loss = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.loss = LossConfig()
          self.loss.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TrainConfig')
    if self.logging_config != None:
      oprot.writeFieldBegin('logging_config', TType.STRUCT, 1)
      self.logging_config.write(oprot)
      oprot.writeFieldEnd()
    if self.nepochs != None:
      oprot.writeFieldBegin('nepochs', TType.I32, 3)
      oprot.writeI32(self.nepochs)
      oprot.writeFieldEnd()
    if self.early_stop_on_val_loss != None:
      oprot.writeFieldBegin('early_stop_on_val_loss', TType.BOOL, 5)
      oprot.writeBool(self.early_stop_on_val_loss)
      oprot.writeFieldEnd()
    if self.loss != None:
      oprot.writeFieldBegin('loss', TType.STRUCT, 6)
      self.loss.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.logging_config is not None:
      value = pprint.pformat(self.logging_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    logging_config=%s' % (value))
    if self.nepochs is not None:
      value = pprint.pformat(self.nepochs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nepochs=%s' % (value))
    if self.early_stop_on_val_loss is not None:
      value = pprint.pformat(self.early_stop_on_val_loss, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    early_stop_on_val_loss=%s' % (value))
    if self.loss is not None:
      value = pprint.pformat(self.loss, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loss=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EvalConfig:
  """
  Attributes:
   - logging_config
   - loss
   - compute_ne
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.logging_config = LoggingConfig()
          self.logging_config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.loss = LossConfig()
          self.loss.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.compute_ne = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EvalConfig')
    if self.logging_config != None:
      oprot.writeFieldBegin('logging_config', TType.STRUCT, 1)
      self.logging_config.write(oprot)
      oprot.writeFieldEnd()
    if self.loss != None:
      oprot.writeFieldBegin('loss', TType.STRUCT, 2)
      self.loss.write(oprot)
      oprot.writeFieldEnd()
    if self.compute_ne != None:
      oprot.writeFieldBegin('compute_ne', TType.BOOL, 3)
      oprot.writeBool(self.compute_ne)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.logging_config is not None:
      value = pprint.pformat(self.logging_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    logging_config=%s' % (value))
    if self.loss is not None:
      value = pprint.pformat(self.loss, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loss=%s' % (value))
    if self.compute_ne is not None:
      value = pprint.pformat(self.compute_ne, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    compute_ne=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CheckpointConfig:
  """
  Attributes:
   - ckp_interval
   - ckp_path
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ckp_interval = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ckp_path = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckpointConfig')
    if self.ckp_interval != None:
      oprot.writeFieldBegin('ckp_interval', TType.I32, 1)
      oprot.writeI32(self.ckp_interval)
      oprot.writeFieldEnd()
    if self.ckp_path != None:
      oprot.writeFieldBegin('ckp_path', TType.STRING, 2)
      oprot.writeString(self.ckp_path.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ckp_path, bytes) else oprot.writeString(self.ckp_path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.ckp_interval is not None:
      value = pprint.pformat(self.ckp_interval, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ckp_interval=%s' % (value))
    if self.ckp_path is not None:
      value = pprint.pformat(self.ckp_path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ckp_path=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KoskiReaderConfig:
  """
  Attributes:
   - prefetch_capacity
   - pin_memory
   - num_workers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.prefetch_capacity = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.pin_memory = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_workers = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KoskiReaderConfig')
    if self.prefetch_capacity != None:
      oprot.writeFieldBegin('prefetch_capacity', TType.I64, 1)
      oprot.writeI64(self.prefetch_capacity)
      oprot.writeFieldEnd()
    if self.pin_memory != None:
      oprot.writeFieldBegin('pin_memory', TType.BOOL, 2)
      oprot.writeBool(self.pin_memory)
      oprot.writeFieldEnd()
    if self.num_workers != None:
      oprot.writeFieldBegin('num_workers', TType.I32, 3)
      oprot.writeI32(self.num_workers)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.prefetch_capacity is not None:
      value = pprint.pformat(self.prefetch_capacity, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prefetch_capacity=%s' % (value))
    if self.pin_memory is not None:
      value = pprint.pformat(self.pin_memory, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    pin_memory=%s' % (value))
    if self.num_workers is not None:
      value = pprint.pformat(self.num_workers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_workers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PerformanceConfig:
  """
  Attributes:
   - use_gpu
   - num_readers
   - num_trainers
   - ckp_config
   - data_queue_maxsize
   - reader_threads
   - num_gpu
   - enable_profiling
   - koski
   - omp_num_threads
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.use_gpu = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.num_readers = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_trainers = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ckp_config = CheckpointConfig()
          self.ckp_config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.data_queue_maxsize = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.reader_threads = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.num_gpu = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.enable_profiling = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.koski = KoskiReaderConfig()
          self.koski.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.omp_num_threads = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PerformanceConfig')
    if self.use_gpu != None:
      oprot.writeFieldBegin('use_gpu', TType.BOOL, 1)
      oprot.writeBool(self.use_gpu)
      oprot.writeFieldEnd()
    if self.num_readers != None:
      oprot.writeFieldBegin('num_readers', TType.I32, 2)
      oprot.writeI32(self.num_readers)
      oprot.writeFieldEnd()
    if self.num_trainers != None:
      oprot.writeFieldBegin('num_trainers', TType.I32, 3)
      oprot.writeI32(self.num_trainers)
      oprot.writeFieldEnd()
    if self.ckp_config != None:
      oprot.writeFieldBegin('ckp_config', TType.STRUCT, 4)
      self.ckp_config.write(oprot)
      oprot.writeFieldEnd()
    if self.data_queue_maxsize != None:
      oprot.writeFieldBegin('data_queue_maxsize', TType.I32, 5)
      oprot.writeI32(self.data_queue_maxsize)
      oprot.writeFieldEnd()
    if self.reader_threads != None:
      oprot.writeFieldBegin('reader_threads', TType.I32, 6)
      oprot.writeI32(self.reader_threads)
      oprot.writeFieldEnd()
    if self.num_gpu != None:
      oprot.writeFieldBegin('num_gpu', TType.I32, 7)
      oprot.writeI32(self.num_gpu)
      oprot.writeFieldEnd()
    if self.enable_profiling != None and self.enable_profiling != self.thrift_spec[8][4]:
      oprot.writeFieldBegin('enable_profiling', TType.BOOL, 8)
      oprot.writeBool(self.enable_profiling)
      oprot.writeFieldEnd()
    if self.koski != None:
      oprot.writeFieldBegin('koski', TType.STRUCT, 9)
      self.koski.write(oprot)
      oprot.writeFieldEnd()
    if self.omp_num_threads != None and self.omp_num_threads != self.thrift_spec[10][4]:
      oprot.writeFieldBegin('omp_num_threads', TType.I32, 10)
      oprot.writeI32(self.omp_num_threads)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.use_gpu is not None:
      value = pprint.pformat(self.use_gpu, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    use_gpu=%s' % (value))
    if self.num_readers is not None:
      value = pprint.pformat(self.num_readers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_readers=%s' % (value))
    if self.num_trainers is not None:
      value = pprint.pformat(self.num_trainers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_trainers=%s' % (value))
    if self.ckp_config is not None:
      value = pprint.pformat(self.ckp_config, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ckp_config=%s' % (value))
    if self.data_queue_maxsize is not None:
      value = pprint.pformat(self.data_queue_maxsize, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data_queue_maxsize=%s' % (value))
    if self.reader_threads is not None:
      value = pprint.pformat(self.reader_threads, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    reader_threads=%s' % (value))
    if self.num_gpu is not None:
      value = pprint.pformat(self.num_gpu, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    num_gpu=%s' % (value))
    if self.enable_profiling is not None:
      value = pprint.pformat(self.enable_profiling, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enable_profiling=%s' % (value))
    if self.koski is not None:
      value = pprint.pformat(self.koski, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    koski=%s' % (value))
    if self.omp_num_threads is not None:
      value = pprint.pformat(self.omp_num_threads, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    omp_num_threads=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(DataFromFileConfig)
DataFromFileConfig.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data_file', True, None, 2, ), # 1
  (2, TType.I32, 'batch_size', None, 100, 2, ), # 2
  (3, TType.I32, 'num_batches', None, -1, 2, ), # 3
  (4, TType.LIST, 'splits', (TType.FLOAT,None), [
    0.800000,
    0.100000,
  ], 2, ), # 4
  (5, TType.I32, 'num_samples_meta', None, 100000, 2, ), # 5
)

DataFromFileConfig.thrift_struct_annotations = {
}
DataFromFileConfig.thrift_field_annotations = {
}

def DataFromFileConfig__init__(self, data_file=None, batch_size=DataFromFileConfig.thrift_spec[2][4], num_batches=DataFromFileConfig.thrift_spec[3][4], splits=DataFromFileConfig.thrift_spec[4][4], num_samples_meta=DataFromFileConfig.thrift_spec[5][4],):
  self.data_file = data_file
  self.batch_size = batch_size
  self.num_batches = num_batches
  if splits is self.thrift_spec[4][4]:
    splits = [
    0.800000,
    0.100000,
  ]
  self.splits = splits
  self.num_samples_meta = num_samples_meta

DataFromFileConfig.__init__ = DataFromFileConfig__init__

def DataFromFileConfig__setstate__(self, state):
  state.setdefault('data_file', None)
  state.setdefault('batch_size', 100)
  state.setdefault('num_batches', -1)
  state.setdefault('splits', [
    0.800000,
    0.100000,
  ])
  state.setdefault('num_samples_meta', 100000)
  self.__dict__ = state

DataFromFileConfig.__getstate__ = lambda self: self.__dict__.copy()
DataFromFileConfig.__setstate__ = DataFromFileConfig__setstate__

all_structs.append(DataConfig)
DataConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'from_file', [DataFromFileConfig, DataFromFileConfig.thrift_spec, False], None, 2, ), # 1
)

DataConfig.thrift_struct_annotations = {
}
DataConfig.thrift_field_annotations = {
}

def DataConfig__init__(self, from_file=None,):
  self.field = 0
  self.value = None
  if from_file is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = from_file

DataConfig.__init__ = DataConfig__init__

all_structs.append(MicroClose)
MicroClose.thrift_spec = (
)

MicroClose.thrift_struct_annotations = {
}
MicroClose.thrift_field_annotations = {
}

all_structs.append(MicroMLPConfig)
MicroMLPConfig.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'arc', (TType.I32,None), None, 2, ), # 1
)

MicroMLPConfig.thrift_struct_annotations = {
}
MicroMLPConfig.thrift_field_annotations = {
}

def MicroMLPConfig__init__(self, arc=None,):
  self.arc = arc

MicroMLPConfig.__init__ = MicroMLPConfig__init__

def MicroMLPConfig__setstate__(self, state):
  state.setdefault('arc', None)
  self.__dict__ = state

MicroMLPConfig.__getstate__ = lambda self: self.__dict__.copy()
MicroMLPConfig.__setstate__ = MicroMLPConfig__setstate__

all_structs.append(MicroCINConfig)
MicroCINConfig.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'arc', (TType.I32,None), None, 2, ), # 1
  (2, TType.LIST, 'num_of_layers', (TType.I32,None), [
    1,
    2,
    3,
  ], 2, ), # 2
)

MicroCINConfig.thrift_struct_annotations = {
}
MicroCINConfig.thrift_field_annotations = {
}

def MicroCINConfig__init__(self, arc=None, num_of_layers=MicroCINConfig.thrift_spec[2][4],):
  self.arc = arc
  if num_of_layers is self.thrift_spec[2][4]:
    num_of_layers = [
    1,
    2,
    3,
  ]
  self.num_of_layers = num_of_layers

MicroCINConfig.__init__ = MicroCINConfig__init__

def MicroCINConfig__setstate__(self, state):
  state.setdefault('arc', None)
  state.setdefault('num_of_layers', [
    1,
    2,
    3,
  ])
  self.__dict__ = state

MicroCINConfig.__getstate__ = lambda self: self.__dict__.copy()
MicroCINConfig.__setstate__ = MicroCINConfig__setstate__

all_structs.append(MicroAttentionConfig)
MicroAttentionConfig.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'num_of_layers', (TType.I32,None), [
    1,
    2,
    3,
  ], 2, ), # 1
  (2, TType.LIST, 'num_of_heads', (TType.I32,None), [
    1,
    2,
    3,
  ], 2, ), # 2
  (3, TType.LIST, 'att_embed_dim', (TType.I32,None), [
    10,
  ], 2, ), # 3
  (4, TType.LIST, 'dropout_prob', (TType.FLOAT,None), [
    0.00000,
    0.200000,
    0.400000,
  ], 2, ), # 4
)

MicroAttentionConfig.thrift_struct_annotations = {
}
MicroAttentionConfig.thrift_field_annotations = {
}

def MicroAttentionConfig__init__(self, num_of_layers=MicroAttentionConfig.thrift_spec[1][4], num_of_heads=MicroAttentionConfig.thrift_spec[2][4], att_embed_dim=MicroAttentionConfig.thrift_spec[3][4], dropout_prob=MicroAttentionConfig.thrift_spec[4][4],):
  if num_of_layers is self.thrift_spec[1][4]:
    num_of_layers = [
    1,
    2,
    3,
  ]
  self.num_of_layers = num_of_layers
  if num_of_heads is self.thrift_spec[2][4]:
    num_of_heads = [
    1,
    2,
    3,
  ]
  self.num_of_heads = num_of_heads
  if att_embed_dim is self.thrift_spec[3][4]:
    att_embed_dim = [
    10,
  ]
  self.att_embed_dim = att_embed_dim
  if dropout_prob is self.thrift_spec[4][4]:
    dropout_prob = [
    0.00000,
    0.200000,
    0.400000,
  ]
  self.dropout_prob = dropout_prob

MicroAttentionConfig.__init__ = MicroAttentionConfig__init__

def MicroAttentionConfig__setstate__(self, state):
  state.setdefault('num_of_layers', [
    1,
    2,
    3,
  ])
  state.setdefault('num_of_heads', [
    1,
    2,
    3,
  ])
  state.setdefault('att_embed_dim', [
    10,
  ])
  state.setdefault('dropout_prob', [
    0.00000,
    0.200000,
    0.400000,
  ])
  self.__dict__ = state

MicroAttentionConfig.__getstate__ = lambda self: self.__dict__.copy()
MicroAttentionConfig.__setstate__ = MicroAttentionConfig__setstate__

all_structs.append(MicroSearchSpaceType)
MicroSearchSpaceType.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'close', [MicroClose, MicroClose.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'micro_mlp', [MicroMLPConfig, MicroMLPConfig.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'micro_cin', [MicroCINConfig, MicroCINConfig.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'micro_attention', [MicroAttentionConfig, MicroAttentionConfig.thrift_spec, False], None, 2, ), # 4
)

MicroSearchSpaceType.thrift_struct_annotations = {
}
MicroSearchSpaceType.thrift_field_annotations = {
}

def MicroSearchSpaceType__init__(self, close=None, micro_mlp=None, micro_cin=None, micro_attention=None,):
  self.field = 0
  self.value = None
  if close is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = close
  if micro_mlp is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = micro_mlp
  if micro_cin is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = micro_cin
  if micro_attention is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = micro_attention

MicroSearchSpaceType.__init__ = MicroSearchSpaceType__init__

all_structs.append(InputDenseAsSparse)
InputDenseAsSparse.thrift_spec = (
)

InputDenseAsSparse.thrift_struct_annotations = {
}
InputDenseAsSparse.thrift_field_annotations = {
}

all_structs.append(FeatureProcessingType)
FeatureProcessingType.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'idasp', [InputDenseAsSparse, InputDenseAsSparse.thrift_spec, False], None, 2, ), # 1
)

FeatureProcessingType.thrift_struct_annotations = {
}
FeatureProcessingType.thrift_field_annotations = {
}

def FeatureProcessingType__init__(self, idasp=None,):
  self.field = 0
  self.value = None
  if idasp is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = idasp

FeatureProcessingType.__init__ = FeatureProcessingType__init__

all_structs.append(NASRecNetConfig)
NASRecNetConfig.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'block_configs', (TType.STRUCT,[block_config.ttypes.BlockConfig, block_config.ttypes.BlockConfig.thrift_spec, True]), None, 2, ), # 1
)

NASRecNetConfig.thrift_struct_annotations = {
}
NASRecNetConfig.thrift_field_annotations = {
}

def NASRecNetConfig__init__(self, block_configs=None,):
  self.block_configs = block_configs

NASRecNetConfig.__init__ = NASRecNetConfig__init__

def NASRecNetConfig__setstate__(self, state):
  state.setdefault('block_configs', None)
  self.__dict__ = state

NASRecNetConfig.__getstate__ = lambda self: self.__dict__.copy()
NASRecNetConfig.__setstate__ = NASRecNetConfig__setstate__

all_structs.append(RandomSearcherConfig)
RandomSearcherConfig.thrift_spec = (
  None, # 0
  (1, TType.I32, 'max_num_block', None, 3, 2, ), # 1
  (2, TType.LIST, 'block_types', (TType.I32,block_config.ttypes.ExtendedBlockType), None, 2, ), # 2
  (3, TType.I32, 'macro_space_type', MacroSearchSpaceType,   1, 2, ), # 3
  None, # 4
  (5, TType.LIST, 'micro_space_types', (TType.STRUCT,[MicroSearchSpaceType, MicroSearchSpaceType.thrift_spec, True]), None, 2, ), # 5
  (6, TType.LIST, 'feature_processing_type', (TType.STRUCT,[FeatureProcessingType, FeatureProcessingType.thrift_spec, True]), [
  ], 2, ), # 6
)

RandomSearcherConfig.thrift_struct_annotations = {
}
RandomSearcherConfig.thrift_field_annotations = {
}

def RandomSearcherConfig__init__(self, max_num_block=RandomSearcherConfig.thrift_spec[1][4], block_types=None, macro_space_type=RandomSearcherConfig.thrift_spec[3][4], micro_space_types=None, feature_processing_type=RandomSearcherConfig.thrift_spec[6][4],):
  self.max_num_block = max_num_block
  self.block_types = block_types
  self.macro_space_type = macro_space_type
  self.micro_space_types = micro_space_types
  if feature_processing_type is self.thrift_spec[6][4]:
    feature_processing_type = [
  ]
  self.feature_processing_type = feature_processing_type

RandomSearcherConfig.__init__ = RandomSearcherConfig__init__

def RandomSearcherConfig__setstate__(self, state):
  state.setdefault('max_num_block', 3)
  state.setdefault('block_types', None)
  state.setdefault('macro_space_type',   1)
  state.setdefault('micro_space_types', None)
  state.setdefault('feature_processing_type', [
  ])
  self.__dict__ = state

RandomSearcherConfig.__getstate__ = lambda self: self.__dict__.copy()
RandomSearcherConfig.__setstate__ = RandomSearcherConfig__setstate__

all_structs.append(EvolutionarySearcherConfig)
EvolutionarySearcherConfig.thrift_spec = (
  None, # 0
  (1, TType.I32, 'max_num_block', None, 3, 2, ), # 1
  (2, TType.LIST, 'block_types', (TType.I32,block_config.ttypes.ExtendedBlockType), None, 2, ), # 2
  (3, TType.I32, 'population_size', None, 10, 2, ), # 3
  (4, TType.I32, 'candidate_size', None, 5, 2, ), # 4
  (5, TType.I32, 'macro_space_type', MacroSearchSpaceType,   1, 2, ), # 5
  None, # 6
  (7, TType.LIST, 'micro_space_types', (TType.STRUCT,[MicroSearchSpaceType, MicroSearchSpaceType.thrift_spec, True]), None, 2, ), # 7
  (8, TType.LIST, 'feature_processing_type', (TType.STRUCT,[FeatureProcessingType, FeatureProcessingType.thrift_spec, True]), [
  ], 2, ), # 8
)

EvolutionarySearcherConfig.thrift_struct_annotations = {
}
EvolutionarySearcherConfig.thrift_field_annotations = {
}

def EvolutionarySearcherConfig__init__(self, max_num_block=EvolutionarySearcherConfig.thrift_spec[1][4], block_types=None, population_size=EvolutionarySearcherConfig.thrift_spec[3][4], candidate_size=EvolutionarySearcherConfig.thrift_spec[4][4], macro_space_type=EvolutionarySearcherConfig.thrift_spec[5][4], micro_space_types=None, feature_processing_type=EvolutionarySearcherConfig.thrift_spec[8][4],):
  self.max_num_block = max_num_block
  self.block_types = block_types
  self.population_size = population_size
  self.candidate_size = candidate_size
  self.macro_space_type = macro_space_type
  self.micro_space_types = micro_space_types
  if feature_processing_type is self.thrift_spec[8][4]:
    feature_processing_type = [
  ]
  self.feature_processing_type = feature_processing_type

EvolutionarySearcherConfig.__init__ = EvolutionarySearcherConfig__init__

def EvolutionarySearcherConfig__setstate__(self, state):
  state.setdefault('max_num_block', 3)
  state.setdefault('block_types', None)
  state.setdefault('population_size', 10)
  state.setdefault('candidate_size', 5)
  state.setdefault('macro_space_type',   1)
  state.setdefault('micro_space_types', None)
  state.setdefault('feature_processing_type', [
  ])
  self.__dict__ = state

EvolutionarySearcherConfig.__getstate__ = lambda self: self.__dict__.copy()
EvolutionarySearcherConfig.__setstate__ = EvolutionarySearcherConfig__setstate__

all_structs.append(SearcherConfig)
SearcherConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'random_searcher', [RandomSearcherConfig, RandomSearcherConfig.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'evolutionary_searcher', [EvolutionarySearcherConfig, EvolutionarySearcherConfig.thrift_spec, False], None, 2, ), # 2
)

SearcherConfig.thrift_struct_annotations = {
}
SearcherConfig.thrift_field_annotations = {
}

def SearcherConfig__init__(self, random_searcher=None, evolutionary_searcher=None,):
  self.field = 0
  self.value = None
  if random_searcher is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = random_searcher
  if evolutionary_searcher is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = evolutionary_searcher

SearcherConfig.__init__ = SearcherConfig__init__

all_structs.append(ModelConfig)
ModelConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'nasrec_net', [NASRecNetConfig, NASRecNetConfig.thrift_spec, False], None, 2, ), # 1
)

ModelConfig.thrift_struct_annotations = {
}
ModelConfig.thrift_field_annotations = {
}

def ModelConfig__init__(self, nasrec_net=None,):
  self.field = 0
  self.value = None
  if nasrec_net is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = nasrec_net

ModelConfig.__init__ = ModelConfig__init__

all_structs.append(SGDOptimConfig)
SGDOptimConfig.thrift_spec = (
  None, # 0
  (1, TType.FLOAT, 'lr', None, 0.0100000, 2, ), # 1
  (2, TType.FLOAT, 'momentum', None, 0.00000, 2, ), # 2
  (3, TType.FLOAT, 'dampening', None, 0.00000, 2, ), # 3
  (4, TType.BOOL, 'nesterov', None, False, 2, ), # 4
  (5, TType.FLOAT, 'weight_decay', None, 0.00000, 2, ), # 5
)

SGDOptimConfig.thrift_struct_annotations = {
}
SGDOptimConfig.thrift_field_annotations = {
}

def SGDOptimConfig__init__(self, lr=SGDOptimConfig.thrift_spec[1][4], momentum=SGDOptimConfig.thrift_spec[2][4], dampening=SGDOptimConfig.thrift_spec[3][4], nesterov=SGDOptimConfig.thrift_spec[4][4], weight_decay=SGDOptimConfig.thrift_spec[5][4],):
  self.lr = lr
  self.momentum = momentum
  self.dampening = dampening
  self.nesterov = nesterov
  self.weight_decay = weight_decay

SGDOptimConfig.__init__ = SGDOptimConfig__init__

def SGDOptimConfig__setstate__(self, state):
  state.setdefault('lr', 0.0100000)
  state.setdefault('momentum', 0.00000)
  state.setdefault('dampening', 0.00000)
  state.setdefault('nesterov', False)
  state.setdefault('weight_decay', 0.00000)
  self.__dict__ = state

SGDOptimConfig.__getstate__ = lambda self: self.__dict__.copy()
SGDOptimConfig.__setstate__ = SGDOptimConfig__setstate__

all_structs.append(AdagradOptimConfig)
AdagradOptimConfig.thrift_spec = (
  None, # 0
  (1, TType.FLOAT, 'lr', None, 0.0100000, 2, ), # 1
  (2, TType.FLOAT, 'lr_decay', None, 0.00000, 2, ), # 2
  (3, TType.FLOAT, 'weight_decay', None, 0.00000, 2, ), # 3
  (4, TType.FLOAT, 'initial_accumulator_value', None, 0.00000, 2, ), # 4
)

AdagradOptimConfig.thrift_struct_annotations = {
}
AdagradOptimConfig.thrift_field_annotations = {
}

def AdagradOptimConfig__init__(self, lr=AdagradOptimConfig.thrift_spec[1][4], lr_decay=AdagradOptimConfig.thrift_spec[2][4], weight_decay=AdagradOptimConfig.thrift_spec[3][4], initial_accumulator_value=AdagradOptimConfig.thrift_spec[4][4],):
  self.lr = lr
  self.lr_decay = lr_decay
  self.weight_decay = weight_decay
  self.initial_accumulator_value = initial_accumulator_value

AdagradOptimConfig.__init__ = AdagradOptimConfig__init__

def AdagradOptimConfig__setstate__(self, state):
  state.setdefault('lr', 0.0100000)
  state.setdefault('lr_decay', 0.00000)
  state.setdefault('weight_decay', 0.00000)
  state.setdefault('initial_accumulator_value', 0.00000)
  self.__dict__ = state

AdagradOptimConfig.__getstate__ = lambda self: self.__dict__.copy()
AdagradOptimConfig.__setstate__ = AdagradOptimConfig__setstate__

all_structs.append(SparseAdamOptimConfig)
SparseAdamOptimConfig.thrift_spec = (
  None, # 0
  (1, TType.FLOAT, 'lr', None, 0.00100000, 2, ), # 1
  (2, TType.FLOAT, 'betas0', None, 0.900000, 2, ), # 2
  (3, TType.FLOAT, 'betas1', None, 0.999000, 2, ), # 3
  (4, TType.FLOAT, 'eps', None, 1.00000e-08, 2, ), # 4
)

SparseAdamOptimConfig.thrift_struct_annotations = {
}
SparseAdamOptimConfig.thrift_field_annotations = {
}

def SparseAdamOptimConfig__init__(self, lr=SparseAdamOptimConfig.thrift_spec[1][4], betas0=SparseAdamOptimConfig.thrift_spec[2][4], betas1=SparseAdamOptimConfig.thrift_spec[3][4], eps=SparseAdamOptimConfig.thrift_spec[4][4],):
  self.lr = lr
  self.betas0 = betas0
  self.betas1 = betas1
  self.eps = eps

SparseAdamOptimConfig.__init__ = SparseAdamOptimConfig__init__

def SparseAdamOptimConfig__setstate__(self, state):
  state.setdefault('lr', 0.00100000)
  state.setdefault('betas0', 0.900000)
  state.setdefault('betas1', 0.999000)
  state.setdefault('eps', 1.00000e-08)
  self.__dict__ = state

SparseAdamOptimConfig.__getstate__ = lambda self: self.__dict__.copy()
SparseAdamOptimConfig.__setstate__ = SparseAdamOptimConfig__setstate__

all_structs.append(AdamOptimConfig)
AdamOptimConfig.thrift_spec = (
  None, # 0
  (1, TType.FLOAT, 'lr', None, 0.00100000, 2, ), # 1
  (2, TType.BOOL, 'amsgrad', None, False, 2, ), # 2
  (3, TType.FLOAT, 'weight_decay', None, 0.00000, 2, ), # 3
  (4, TType.FLOAT, 'betas0', None, 0.900000, 2, ), # 4
  (5, TType.FLOAT, 'betas1', None, 0.999000, 2, ), # 5
  (6, TType.FLOAT, 'eps', None, 1.00000e-08, 2, ), # 6
)

AdamOptimConfig.thrift_struct_annotations = {
}
AdamOptimConfig.thrift_field_annotations = {
}

def AdamOptimConfig__init__(self, lr=AdamOptimConfig.thrift_spec[1][4], amsgrad=AdamOptimConfig.thrift_spec[2][4], weight_decay=AdamOptimConfig.thrift_spec[3][4], betas0=AdamOptimConfig.thrift_spec[4][4], betas1=AdamOptimConfig.thrift_spec[5][4], eps=AdamOptimConfig.thrift_spec[6][4],):
  self.lr = lr
  self.amsgrad = amsgrad
  self.weight_decay = weight_decay
  self.betas0 = betas0
  self.betas1 = betas1
  self.eps = eps

AdamOptimConfig.__init__ = AdamOptimConfig__init__

def AdamOptimConfig__setstate__(self, state):
  state.setdefault('lr', 0.00100000)
  state.setdefault('amsgrad', False)
  state.setdefault('weight_decay', 0.00000)
  state.setdefault('betas0', 0.900000)
  state.setdefault('betas1', 0.999000)
  state.setdefault('eps', 1.00000e-08)
  self.__dict__ = state

AdamOptimConfig.__getstate__ = lambda self: self.__dict__.copy()
AdamOptimConfig.__setstate__ = AdamOptimConfig__setstate__

all_structs.append(RMSpropOptimConfig)
RMSpropOptimConfig.thrift_spec = (
  None, # 0
  (1, TType.FLOAT, 'lr', None, 0.0100000, 2, ), # 1
  (2, TType.FLOAT, 'alpha', None, 0.990000, 2, ), # 2
  (3, TType.FLOAT, 'weight_decay', None, 0.00000, 2, ), # 3
  (4, TType.FLOAT, 'momentum', None, 0.00000, 2, ), # 4
  (5, TType.BOOL, 'centered', None, False, 2, ), # 5
  (6, TType.FLOAT, 'eps', None, 1.00000e-08, 2, ), # 6
)

RMSpropOptimConfig.thrift_struct_annotations = {
}
RMSpropOptimConfig.thrift_field_annotations = {
}

def RMSpropOptimConfig__init__(self, lr=RMSpropOptimConfig.thrift_spec[1][4], alpha=RMSpropOptimConfig.thrift_spec[2][4], weight_decay=RMSpropOptimConfig.thrift_spec[3][4], momentum=RMSpropOptimConfig.thrift_spec[4][4], centered=RMSpropOptimConfig.thrift_spec[5][4], eps=RMSpropOptimConfig.thrift_spec[6][4],):
  self.lr = lr
  self.alpha = alpha
  self.weight_decay = weight_decay
  self.momentum = momentum
  self.centered = centered
  self.eps = eps

RMSpropOptimConfig.__init__ = RMSpropOptimConfig__init__

def RMSpropOptimConfig__setstate__(self, state):
  state.setdefault('lr', 0.0100000)
  state.setdefault('alpha', 0.990000)
  state.setdefault('weight_decay', 0.00000)
  state.setdefault('momentum', 0.00000)
  state.setdefault('centered', False)
  state.setdefault('eps', 1.00000e-08)
  self.__dict__ = state

RMSpropOptimConfig.__getstate__ = lambda self: self.__dict__.copy()
RMSpropOptimConfig.__setstate__ = RMSpropOptimConfig__setstate__

all_structs.append(OptimConfig)
OptimConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'sgd', [SGDOptimConfig, SGDOptimConfig.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'adagrad', [AdagradOptimConfig, AdagradOptimConfig.thrift_spec, False], AdagradOptimConfig(**{
  }), 2, ), # 2
  (3, TType.STRUCT, 'sparse_adam', [SparseAdamOptimConfig, SparseAdamOptimConfig.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'adam', [AdamOptimConfig, AdamOptimConfig.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'rmsprop', [RMSpropOptimConfig, RMSpropOptimConfig.thrift_spec, False], None, 2, ), # 5
)

OptimConfig.thrift_struct_annotations = {
}
OptimConfig.thrift_field_annotations = {
}

def OptimConfig__init__(self, sgd=None, adagrad=OptimConfig.thrift_spec[2][4], sparse_adam=None, adam=None, rmsprop=None,):
  self.field = 0
  self.value = None
  if sgd is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = sgd
  if adagrad is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = adagrad
  if sparse_adam is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = sparse_adam
  if adam is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = adam
  if rmsprop is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = rmsprop

OptimConfig.__init__ = OptimConfig__init__

all_structs.append(SumPooling)
SumPooling.thrift_spec = (
)

SumPooling.thrift_struct_annotations = {
}
SumPooling.thrift_field_annotations = {
}

all_structs.append(AvgPooling)
AvgPooling.thrift_spec = (
)

AvgPooling.thrift_struct_annotations = {
}
AvgPooling.thrift_field_annotations = {
}

all_structs.append(PoolingConfig)
PoolingConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'sum', [SumPooling, SumPooling.thrift_spec, False], SumPooling(**{
  }), 2, ), # 1
  (2, TType.STRUCT, 'avg', [AvgPooling, AvgPooling.thrift_spec, False], None, 2, ), # 2
)

PoolingConfig.thrift_struct_annotations = {
}
PoolingConfig.thrift_field_annotations = {
}

def PoolingConfig__init__(self, sum=PoolingConfig.thrift_spec[1][4], avg=None,):
  self.field = 0
  self.value = None
  if sum is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = sum
  if avg is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = avg

PoolingConfig.__init__ = PoolingConfig__init__

all_structs.append(SparseFeatureItem)
SparseFeatureItem.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.I32, 'hash_size', None, 10000, 2, ), # 2
  (3, TType.I32, 'embed_dim', None, -1, 2, ), # 3
  (4, TType.STRUCT, 'optim', [OptimConfig, OptimConfig.thrift_spec, True], None, 1, ), # 4
  (5, TType.STRUCT, 'pooling', [PoolingConfig, PoolingConfig.thrift_spec, True], PoolingConfig(**{
    "sum" : SumPooling(**{
    }),
  }), 2, ), # 5
)

SparseFeatureItem.thrift_struct_annotations = {
}
SparseFeatureItem.thrift_field_annotations = {
}

def SparseFeatureItem__init__(self, name=None, hash_size=SparseFeatureItem.thrift_spec[2][4], embed_dim=SparseFeatureItem.thrift_spec[3][4], optim=None, pooling=SparseFeatureItem.thrift_spec[5][4],):
  self.name = name
  self.hash_size = hash_size
  self.embed_dim = embed_dim
  self.optim = optim
  if pooling is self.thrift_spec[5][4]:
    pooling = PoolingConfig(**{
    "sum" : SumPooling(**{
    }),
  })
  self.pooling = pooling

SparseFeatureItem.__init__ = SparseFeatureItem__init__

def SparseFeatureItem__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('hash_size', 10000)
  state.setdefault('embed_dim', -1)
  state.setdefault('optim', None)
  state.setdefault('pooling', PoolingConfig(**{
    "sum" : SumPooling(**{
    }),
  }))
  self.__dict__ = state

SparseFeatureItem.__getstate__ = lambda self: self.__dict__.copy()
SparseFeatureItem.__setstate__ = SparseFeatureItem__setstate__

all_structs.append(SparseFeatureConfig)
SparseFeatureConfig.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'features', (TType.STRUCT,[SparseFeatureItem, SparseFeatureItem.thrift_spec, False]), [
  ], 2, ), # 1
  (2, TType.I32, 'embed_dim', None, -1, 2, ), # 2
  (3, TType.STRUCT, 'optim', [OptimConfig, OptimConfig.thrift_spec, True], None, 2, ), # 3
)

SparseFeatureConfig.thrift_struct_annotations = {
}
SparseFeatureConfig.thrift_field_annotations = {
}

def SparseFeatureConfig__init__(self, features=SparseFeatureConfig.thrift_spec[1][4], embed_dim=SparseFeatureConfig.thrift_spec[2][4], optim=None,):
  if features is self.thrift_spec[1][4]:
    features = [
  ]
  self.features = features
  self.embed_dim = embed_dim
  self.optim = optim

SparseFeatureConfig.__init__ = SparseFeatureConfig__init__

def SparseFeatureConfig__setstate__(self, state):
  state.setdefault('features', [
  ])
  state.setdefault('embed_dim', -1)
  state.setdefault('optim', None)
  self.__dict__ = state

SparseFeatureConfig.__getstate__ = lambda self: self.__dict__.copy()
SparseFeatureConfig.__setstate__ = SparseFeatureConfig__setstate__

all_structs.append(DenseFeatureConfig)
DenseFeatureConfig.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'features', (TType.STRING,True), None, 2, ), # 1
  (2, TType.STRUCT, 'optim', [OptimConfig, OptimConfig.thrift_spec, True], None, 2, ), # 2
)

DenseFeatureConfig.thrift_struct_annotations = {
}
DenseFeatureConfig.thrift_field_annotations = {
}

def DenseFeatureConfig__init__(self, features=None, optim=None,):
  self.features = features
  self.optim = optim

DenseFeatureConfig.__init__ = DenseFeatureConfig__init__

def DenseFeatureConfig__setstate__(self, state):
  state.setdefault('features', None)
  state.setdefault('optim', None)
  self.__dict__ = state

DenseFeatureConfig.__getstate__ = lambda self: self.__dict__.copy()
DenseFeatureConfig.__setstate__ = DenseFeatureConfig__setstate__

all_structs.append(FeatureConfig)
FeatureConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'dense', [DenseFeatureConfig, DenseFeatureConfig.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'sparse', [SparseFeatureConfig, SparseFeatureConfig.thrift_spec, False], None, 2, ), # 2
)

FeatureConfig.thrift_struct_annotations = {
}
FeatureConfig.thrift_field_annotations = {
}

def FeatureConfig__init__(self, dense=None, sparse=None,):
  self.dense = dense
  self.sparse = sparse

FeatureConfig.__init__ = FeatureConfig__init__

def FeatureConfig__setstate__(self, state):
  state.setdefault('dense', None)
  state.setdefault('sparse', None)
  self.__dict__ = state

FeatureConfig.__getstate__ = lambda self: self.__dict__.copy()
FeatureConfig.__setstate__ = FeatureConfig__setstate__

all_structs.append(BCEWithLogitsLoss)
BCEWithLogitsLoss.thrift_spec = (
)

BCEWithLogitsLoss.thrift_struct_annotations = {
}
BCEWithLogitsLoss.thrift_field_annotations = {
}

all_structs.append(BCELoss)
BCELoss.thrift_spec = (
)

BCELoss.thrift_struct_annotations = {
}
BCELoss.thrift_field_annotations = {
}

all_structs.append(MSELoss)
MSELoss.thrift_spec = (
)

MSELoss.thrift_struct_annotations = {
}
MSELoss.thrift_field_annotations = {
}

all_structs.append(LossConfig)
LossConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'bcewithlogits', [BCEWithLogitsLoss, BCEWithLogitsLoss.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'bce', [BCELoss, BCELoss.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'mse', [MSELoss, MSELoss.thrift_spec, False], None, 2, ), # 3
)

LossConfig.thrift_struct_annotations = {
}
LossConfig.thrift_field_annotations = {
}

def LossConfig__init__(self, bcewithlogits=None, bce=None, mse=None,):
  self.field = 0
  self.value = None
  if bcewithlogits is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = bcewithlogits
  if bce is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = bce
  if mse is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = mse

LossConfig.__init__ = LossConfig__init__

all_structs.append(LoggingConfig)
LoggingConfig.thrift_spec = (
  None, # 0
  (1, TType.I32, 'log_freq', None, 10000, 2, ), # 1
  (2, TType.I32, 'tb_log_freq', None, -1, 2, ), # 2
  (3, TType.BOOL, 'tb_log_model_weight_hist', None, False, 2, ), # 3
  (4, TType.BOOL, 'tb_log_pr_curve_batch', None, True, 2, ), # 4
  (5, TType.LIST, 'tb_log_model_weight_filter_regex', (TType.STRING,True), [
    "sparse",
  ], 2, ), # 5
)

LoggingConfig.thrift_struct_annotations = {
}
LoggingConfig.thrift_field_annotations = {
}

def LoggingConfig__init__(self, log_freq=LoggingConfig.thrift_spec[1][4], tb_log_freq=LoggingConfig.thrift_spec[2][4], tb_log_model_weight_hist=LoggingConfig.thrift_spec[3][4], tb_log_pr_curve_batch=LoggingConfig.thrift_spec[4][4], tb_log_model_weight_filter_regex=LoggingConfig.thrift_spec[5][4],):
  self.log_freq = log_freq
  self.tb_log_freq = tb_log_freq
  self.tb_log_model_weight_hist = tb_log_model_weight_hist
  self.tb_log_pr_curve_batch = tb_log_pr_curve_batch
  if tb_log_model_weight_filter_regex is self.thrift_spec[5][4]:
    tb_log_model_weight_filter_regex = [
    "sparse",
  ]
  self.tb_log_model_weight_filter_regex = tb_log_model_weight_filter_regex

LoggingConfig.__init__ = LoggingConfig__init__

def LoggingConfig__setstate__(self, state):
  state.setdefault('log_freq', 10000)
  state.setdefault('tb_log_freq', -1)
  state.setdefault('tb_log_model_weight_hist', False)
  state.setdefault('tb_log_pr_curve_batch', True)
  state.setdefault('tb_log_model_weight_filter_regex', [
    "sparse",
  ])
  self.__dict__ = state

LoggingConfig.__getstate__ = lambda self: self.__dict__.copy()
LoggingConfig.__setstate__ = LoggingConfig__setstate__

all_structs.append(TrainConfig)
TrainConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'logging_config', [LoggingConfig, LoggingConfig.thrift_spec, False], None, 2, ), # 1
  None, # 2
  (3, TType.I32, 'nepochs', None, 1, 2, ), # 3
  None, # 4
  (5, TType.BOOL, 'early_stop_on_val_loss', None, True, 2, ), # 5
  (6, TType.STRUCT, 'loss', [LossConfig, LossConfig.thrift_spec, True], LossConfig(**{
    "bcewithlogits" : BCEWithLogitsLoss(**{
    }),
  }), 2, ), # 6
)

TrainConfig.thrift_struct_annotations = {
}
TrainConfig.thrift_field_annotations = {
}

def TrainConfig__init__(self, logging_config=None, nepochs=TrainConfig.thrift_spec[3][4], early_stop_on_val_loss=TrainConfig.thrift_spec[5][4], loss=TrainConfig.thrift_spec[6][4],):
  self.logging_config = logging_config
  self.nepochs = nepochs
  self.early_stop_on_val_loss = early_stop_on_val_loss
  if loss is self.thrift_spec[6][4]:
    loss = LossConfig(**{
    "bcewithlogits" : BCEWithLogitsLoss(**{
    }),
  })
  self.loss = loss

TrainConfig.__init__ = TrainConfig__init__

def TrainConfig__setstate__(self, state):
  state.setdefault('logging_config', None)
  state.setdefault('nepochs', 1)
  state.setdefault('early_stop_on_val_loss', True)
  state.setdefault('loss', LossConfig(**{
    "bcewithlogits" : BCEWithLogitsLoss(**{
    }),
  }))
  self.__dict__ = state

TrainConfig.__getstate__ = lambda self: self.__dict__.copy()
TrainConfig.__setstate__ = TrainConfig__setstate__

all_structs.append(EvalConfig)
EvalConfig.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'logging_config', [LoggingConfig, LoggingConfig.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'loss', [LossConfig, LossConfig.thrift_spec, True], LossConfig(**{
    "bcewithlogits" : BCEWithLogitsLoss(**{
    }),
  }), 2, ), # 2
  (3, TType.BOOL, 'compute_ne', None, True, 2, ), # 3
)

EvalConfig.thrift_struct_annotations = {
}
EvalConfig.thrift_field_annotations = {
}

def EvalConfig__init__(self, logging_config=None, loss=EvalConfig.thrift_spec[2][4], compute_ne=EvalConfig.thrift_spec[3][4],):
  self.logging_config = logging_config
  if loss is self.thrift_spec[2][4]:
    loss = LossConfig(**{
    "bcewithlogits" : BCEWithLogitsLoss(**{
    }),
  })
  self.loss = loss
  self.compute_ne = compute_ne

EvalConfig.__init__ = EvalConfig__init__

def EvalConfig__setstate__(self, state):
  state.setdefault('logging_config', None)
  state.setdefault('loss', LossConfig(**{
    "bcewithlogits" : BCEWithLogitsLoss(**{
    }),
  }))
  state.setdefault('compute_ne', True)
  self.__dict__ = state

EvalConfig.__getstate__ = lambda self: self.__dict__.copy()
EvalConfig.__setstate__ = EvalConfig__setstate__

all_structs.append(CheckpointConfig)
CheckpointConfig.thrift_spec = (
  None, # 0
  (1, TType.I32, 'ckp_interval', None, 10, 2, ), # 1
  (2, TType.STRING, 'ckp_path', True, "", 2, ), # 2
)

CheckpointConfig.thrift_struct_annotations = {
}
CheckpointConfig.thrift_field_annotations = {
}

def CheckpointConfig__init__(self, ckp_interval=CheckpointConfig.thrift_spec[1][4], ckp_path=CheckpointConfig.thrift_spec[2][4],):
  self.ckp_interval = ckp_interval
  self.ckp_path = ckp_path

CheckpointConfig.__init__ = CheckpointConfig__init__

def CheckpointConfig__setstate__(self, state):
  state.setdefault('ckp_interval', 10)
  state.setdefault('ckp_path', "")
  self.__dict__ = state

CheckpointConfig.__getstate__ = lambda self: self.__dict__.copy()
CheckpointConfig.__setstate__ = CheckpointConfig__setstate__

all_structs.append(KoskiReaderConfig)
KoskiReaderConfig.thrift_spec = (
  None, # 0
  (1, TType.I64, 'prefetch_capacity', None, 128, 2, ), # 1
  (2, TType.BOOL, 'pin_memory', None, True, 2, ), # 2
  (3, TType.I32, 'num_workers', None, 4, 2, ), # 3
)

KoskiReaderConfig.thrift_struct_annotations = {
}
KoskiReaderConfig.thrift_field_annotations = {
}

def KoskiReaderConfig__init__(self, prefetch_capacity=KoskiReaderConfig.thrift_spec[1][4], pin_memory=KoskiReaderConfig.thrift_spec[2][4], num_workers=KoskiReaderConfig.thrift_spec[3][4],):
  self.prefetch_capacity = prefetch_capacity
  self.pin_memory = pin_memory
  self.num_workers = num_workers

KoskiReaderConfig.__init__ = KoskiReaderConfig__init__

def KoskiReaderConfig__setstate__(self, state):
  state.setdefault('prefetch_capacity', 128)
  state.setdefault('pin_memory', True)
  state.setdefault('num_workers', 4)
  self.__dict__ = state

KoskiReaderConfig.__getstate__ = lambda self: self.__dict__.copy()
KoskiReaderConfig.__setstate__ = KoskiReaderConfig__setstate__

all_structs.append(PerformanceConfig)
PerformanceConfig.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'use_gpu', None, False, 2, ), # 1
  (2, TType.I32, 'num_readers', None, 4, 2, ), # 2
  (3, TType.I32, 'num_trainers', None, 1, 2, ), # 3
  (4, TType.STRUCT, 'ckp_config', [CheckpointConfig, CheckpointConfig.thrift_spec, False], CheckpointConfig(**{
    "ckp_interval" : 10,
  }), 2, ), # 4
  (5, TType.I32, 'data_queue_maxsize', None, 100, 2, ), # 5
  (6, TType.I32, 'reader_threads', None, 8, 2, ), # 6
  (7, TType.I32, 'num_gpu', None, 1, 2, ), # 7
  (8, TType.BOOL, 'enable_profiling', None, False, 1, ), # 8
  (9, TType.STRUCT, 'koski', [KoskiReaderConfig, KoskiReaderConfig.thrift_spec, False], None, 1, ), # 9
  (10, TType.I32, 'omp_num_threads', None, 0, 1, ), # 10
)

PerformanceConfig.thrift_struct_annotations = {
}
PerformanceConfig.thrift_field_annotations = {
}

def PerformanceConfig__init__(self, use_gpu=PerformanceConfig.thrift_spec[1][4], num_readers=PerformanceConfig.thrift_spec[2][4], num_trainers=PerformanceConfig.thrift_spec[3][4], ckp_config=PerformanceConfig.thrift_spec[4][4], data_queue_maxsize=PerformanceConfig.thrift_spec[5][4], reader_threads=PerformanceConfig.thrift_spec[6][4], num_gpu=PerformanceConfig.thrift_spec[7][4], enable_profiling=PerformanceConfig.thrift_spec[8][4], koski=None, omp_num_threads=PerformanceConfig.thrift_spec[10][4],):
  self.use_gpu = use_gpu
  self.num_readers = num_readers
  self.num_trainers = num_trainers
  if ckp_config is self.thrift_spec[4][4]:
    ckp_config = CheckpointConfig(**{
    "ckp_interval" : 10,
  })
  self.ckp_config = ckp_config
  self.data_queue_maxsize = data_queue_maxsize
  self.reader_threads = reader_threads
  self.num_gpu = num_gpu
  self.enable_profiling = enable_profiling
  self.koski = koski
  self.omp_num_threads = omp_num_threads

PerformanceConfig.__init__ = PerformanceConfig__init__

def PerformanceConfig__setstate__(self, state):
  state.setdefault('use_gpu', False)
  state.setdefault('num_readers', 4)
  state.setdefault('num_trainers', 1)
  state.setdefault('ckp_config', CheckpointConfig(**{
    "ckp_interval" : 10,
  }))
  state.setdefault('data_queue_maxsize', 100)
  state.setdefault('reader_threads', 8)
  state.setdefault('num_gpu', 1)
  state.setdefault('enable_profiling', False)
  state.setdefault('koski', None)
  state.setdefault('omp_num_threads', 0)
  self.__dict__ = state

PerformanceConfig.__getstate__ = lambda self: self.__dict__.copy()
PerformanceConfig.__setstate__ = PerformanceConfig__setstate__

fix_spec(all_structs)
del all_structs
